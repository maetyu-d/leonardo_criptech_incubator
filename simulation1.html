<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dual Bot World ‚Äî v9.3</title>
<style>
  :root{
    --bg:#0b0f12; --panel:#0f1419; --muted:#15202b; --text:#e6f1ff; --sub:#9fb3c8;
    --teal:#00e5ff; --green:#33FF33; --orange:#FF8C00; --pink:#ff4db3; --blue:#58a6ff; --ring:#7dd3fc;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(15,20,25,.95),rgba(15,20,25,.85));backdrop-filter:blur(6px);border-bottom:1px solid var(--muted)}
  .bar{display:flex;flex-wrap:wrap;gap:.75rem;align-items:center;padding:.6rem .9rem}
  .title{font-weight:700;letter-spacing:.2px;margin-right:8px}
  .spacer{flex:1}
  .group{display:flex;align-items:center;gap:.5rem;background:#0d1318;padding:.4rem .6rem;border:1px solid #141c24;border-radius:10px}
  label{font-size:.85rem;color:var(--sub)}
  select,input[type=range],input[type=number]{background:#0b1217;color:var(--text);border:1px solid #1a2632;border-radius:8px;padding:.3rem .5rem;accent-color:var(--teal)}
  input[type=checkbox]{accent-color:var(--teal)}
  button{background:#0b1217;border:1px solid #173042;color:var(--text);padding:.35rem .6rem;border-radius:10px;cursor:pointer;font-weight:600}
  button:hover{border-color:#245e79;box-shadow:0 0 0 3px rgba(0,229,255,.08) inset}
  .danger{border-color:#40222a}.danger:hover{border-color:#7f3443}
  .accent{border-color:#1f4858}.accent:hover{border-color:#2a6b86}
  .mini{padding:0 .4rem;line-height:1.2rem;height:1.4rem;border-radius:6px}
  #stats{font-variant-numeric:tabular-nums;font-size:.9rem;color:var(--sub)}

  .wrap{display:flex;gap:12px;padding:12px}
  #canvas-holder{flex:1;display:flex;gap:12px;min-height:calc(100vh - 82px)}
  .left{flex:1;position:relative;background:#090d10;border:1px solid var(--muted);border-radius:14px;overflow:hidden}
  .right{width:360px;display:flex;flex-direction:column;gap:12px}
  .panel{background:var(--panel);border:1px solid var(--muted);border-radius:14px;padding:10px}
  .panel h3{margin:0 0 .5rem 0;font-size:.95rem;color:var(--sub);letter-spacing:.3px}
  canvas{display:block}
  #main{width:100%;height:100%}
  #minimap{width:100%;height:260px;background:#0a0f14;border-radius:10px}
  textarea{width:100%;min-height:220px;max-height:360px;background:#0a0f14;color:var(--text);border:1px solid #13202c;border-radius:10px;padding:10px;resize:vertical;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.88rem;line-height:1.4}
  .row{display:flex;gap:8px}.row>*{flex:1}
  .legend{display:flex;gap:8px;flex-wrap:wrap;font-size:.8rem;color:var(--sub)}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:.2rem .5rem;border-radius:999px;border:1px solid var(--muted);background:#0b1217}
  .dot{width:10px;height:10px;border-radius:50%}
</style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="title">Dual Bot World</div>
      <div class="group" title="Simulation speed">
        <label for="speed">Speed</label>
        \1<option value="100">100√ó</option></select>
      </div>
      <div class="group" title="Simulation speed">
  <label for="speed">Speed</label>
  <select id="speed">
    <option value="1">1√ó</option>
    <option value="5">5√ó</option>
    <option value="100">100√ó</option>
  </select>
</div>
<div class="group">
        <label for="followSel">Follow</label>
        <select id="followSel"><option value="NONE">None</option><option value="GREEN" selected>Green</option><option value="ORANGE">Orange</option></select>
        <label><input type="checkbox" id="showTrails" checked/> Trails</label>
        <label><input type="checkbox" id="showAccess"/> Accessibility overlay</label>
        <label><input type="checkbox" id="showGoals" checked/> Goals</label>
              <label><input type="checkbox" id="colorTiles"/> Use coloured tiles</label>
      </div>
      <div class="group" style="min-width:300px" title="Below this, green bots hard-repel from tiles">
        <label for="avoid">Avoid-threshold</label>
        <input id="avoid" type="range" min="0" max="1" step="0.01" value="0.25"/>
        <span id="avoidVal" style="min-width:2.4rem;text-align:right">0.25</span>
      </div>

      <div class="group" style="min-width:260px" title="On-screen trail thickness">
        <label for="trailW">Trail width</label>
        <input id="trailW" type="range" min="0.5" max="100" step="0.5" value="3"/>
        <span id="trailWVal" style="min-width:2.4rem;text-align:right">3</span>
      </div>

<div class="group" style="min-width:280px" title="Trail transparency (50%‚Äì100%)">
  <label for="trailAlpha">Trail opacity</label>
  <input id="trailAlpha" type="range" min="0.5" max="1" step="0.01" value="0.7"/>
  <span id="trailAlphaVal" style="min-width:3.2rem;text-align:right">70%</span>
</div>

      <div class="group" style="min-width:320px" title="Green bot wobble amplitude (visual limp)">
        <label for="wobAmp">Wobble</label>
        <input id="wobAmp" type="range" min="0" max="3" step="0.05" value="0.6"/>
        <span id="wobAmpVal" style="min-width:2.4rem;text-align:right">0.60</span>
      </div>
      <div class="group" style="min-width:320px" title="Green bot inherent left-lean (pull left)">
        <label for="leftBias">Left-bias</label>
        <input id="leftBias" type="range" min="0" max="0.2" step="0.005" value="0.025"/>
        <span id="leftBiasVal" style="min-width:2.4rem;text-align:right">0.025</span>
      </div>
      <div class="group" style="min-width:320px" title="Scale both bots' fatigue rates while preserving their % difference">
        <label for="fatigueScale">Fatigue</label>
        <input id="fatigueScale" type="range" min="0.1" max="3" step="0.05" value="1"/>
        <span id="fatigueScaleVal" style="min-width:3.2rem;text-align:right">1.00√ó</span>
      </div>

      <div class="group" style="min-width:360px" title="Set number of bots (overridable via DSL)">
        <label for="greenCount">Green</label>
        <button id="greenMinus" class="mini">‚Äì</button>
        <input id="greenCount" type="number" min="0" max="200" step="1" value="1" style="width:64px"/>
        <button id="greenPlus" class="mini">+</button>
        <label for="orangeCount">Orange</label>
        <button id="orangeMinus" class="mini">‚Äì</button>
        <input id="orangeCount" type="number" min="0" max="200" step="1" value="1" style="width:64px"/>
        <button id="orangePlus" class="mini">+</button>
        <button id="applyCounts" class="accent">Apply</button>
      </div>

      <div class="group">
        <button id="pause" class="accent">‚è∏ Pause</button>
        <button id="reset" class="danger">‚ü≤ Reset</button>
        <button id="saveTrails" class="accent">üíæ Save Trails PNG</button>
        <label style="margin-left:8px"><input type="checkbox" id="exportTiles"/> Include accessibility tiles</label>
      </div>

      <div class="spacer"></div>
      <div id="stats">t=0.0s ¬∑ 1√ó ¬∑ G(avg) 0% ¬∑ O(avg) 0% ¬∑ access 0.00 ¬∑ mode MOVE</div>
    </div>
  </header>

  <div class="wrap">
    <div id="canvas-holder" class="panel left">
      <canvas id="main"></canvas>
      <div class="right">
        <div class="panel">
          <h3>Minimap</h3>
          <canvas id="minimap" width="340" height="260"></canvas>
          <div class="legend" style="margin-top:.4rem">
            <span class="chip"><span class="dot" style="background:var(--green)"></span> Green bots</span>
            <span class="chip"><span class="dot" style="background:var(--orange)"></span> Orange bots</span>
            <span class="chip"><span class="dot" style="background:var(--ring)"></span> Goal</span>
            <span class="chip"><span class="dot" style="background:var(--blue)"></span> Bench</span>
            <span class="chip"><span class="dot" style="background:var(--pink)"></span> Obstacle</span>
          </div>
        </div>
        <div class="panel">
          <h3>DSL ‚Äî World & Programs</h3>
          <textarea id="dsl" placeholder="Deep DSL + Programs (one per line)
# WORLD & CAMERA
WORLD SIZE=10000 TILES=50 EDGE=250 WRAP=OFF SEED=42
CAMERA X=5000 Y=5000 ZOOM=0.35 FOLLOW=GREEN

# BOTS (counts & defaults)
BOTS GREEN 6
BOTS ORANGE 6
SET GREEN avoid=0.30 wobbleAmp=0.7 wobbleFreq=1.5 leftBias=0.03 hardRepel=2.0 turnLeft=2.2 turnRight=1.3 speed=85 fatigueRate=0.010 goalWeight=1.1
SET ORANGE jitter=1.0 turn=2.0 speed=95 fatigueRate=0.005 goalWeight=0.4
BOT 3 TYPE=GREEN speed=120 leftBias=0.05 restSeconds=10

# PROGRAM PER TYPE
PROGRAM GREEN
  SET restSeconds=12 wobbleAmp=0.8
  RULE IF ACCESS<0.25 THEN HARD_REPEL=2.5
  RULE IF FATIGUE>=1.0 THEN TO_BENCH
  RULE IF NEARGOAL<400 THEN ATTRACT_GOAL=0.8
  RULE IF RANDOM<0.2 THEN NUDGE_LEFT=0.3
END

PROGRAM ORANGE
  SET jitter=1.2 turn=2.1
  RULE IF EDGE<200 THEN TURN_LEFT=1.0
  RULE IF RANDOM<0.05 THEN TURN_RIGHT=0.6
END

# PROGRAM A SINGLE BOT (index)
PROGRAM BOT 0
  SET speed=140
  RULE IF GOAL_COUNT<1 THEN SPAWN_GOAL
  RULE IF NEAROBSTACLE>0 THEN TURN_RIGHT=1.4
END

# OBSTACLE behaviour
OBSTACLES BLOCK=GREEN    # default: green blocked, orange pass-through

# OBJECTS
CLEAR BENCHES
BENCH RANDOM 6
GOAL RANDOM 3 TTL=60 R=90
OBSTACLE 2000 2000 2600 2100 2500 2600 1900 2550 END

# GOALS SPAWNER (DSL)
GOALS INTERVAL=30 MAX=8

# EXPORT / PNG
EXPORT SIZE=10000
TRAIL_LINEWIDTH=4
SAVE TRAILS NAME=trails.png

# TOGGLES
TRAILS ON
GOALS ON
ACCESS OVERLAY OFF
SPEED 5X
"></textarea>
          <div class="row" style="margin-top:.5rem">
            <button id="runDSL" class="accent">‚ñ∂ Run DSL</button>
            <button id="clearDSL">Clear</button>
          </div>
          <div id="dslStatus" class="note" style="margin-top:.4rem">Ready.</div>
        </div>
      </div>
    </div>
  </div>

<script>
// ====== Core & Config ======
  const CSS = getComputedStyle(document.documentElement);
  let COLOR_GREEN = CSS.getPropertyValue('--green').trim();
  let COLOR_ORANGE = CSS.getPropertyValue('--orange').trim();
  const COLOR_RING = CSS.getPropertyValue('--ring').trim();
let WORLD_SIZE = 10000, TILE_N = 50, TILE_SIZE = WORLD_SIZE / TILE_N, EDGE_REPEL_DIST = 250, WRAP = false;
const TWO_PI = Math.PI * 2;

// Export config (DSL tunable)
let EXPORT_SIZE = 10000;
let EXPORT_LINEWIDTH = 4;
let RUNTIME_TRAIL_LINEWIDTH = 3;
// Trail alpha (runtime adjustable)
let TRAIL_ALPHA = 0.7;

// Goal auto-spawn (DSL tunable)
let goalInterval = 30;   // seconds (simulation time)
let goalMax = 8;         // soft cap to avoid clutter
let lastGoalSpawn = 0;

// Obstacle blocking flags (DSL configurable)
let OBST_BLOCK_GREEN = true;
let OBST_BLOCK_ORANGE = false;

// Fatigue scaling
let FATIGUE_SCALE = 1;
let BASE_FATIGUE = { GREEN: 0.010, ORANGE: 0.005 };

// ====== Random (seeded) ======
function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
let seed=Math.floor(Math.random()*1e9), rand=mulberry32(seed);

// ====== Utility ======
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const angleWrap=a=>{ while(a<=-Math.PI) a+=TWO_PI; while(a>Math.PI) a-=TWO_PI; return a; };
const angleLerp=(a,b,t)=>{ let d=angleWrap(b-a); return a + d*t; };

function pointInPoly(pt, poly){
  const x=pt.x, y=pt.y; let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
    const inter=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-9)+xi);
    if(inter) inside=!inside;
  }
  return inside;
}
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function edgeDistance(p){ return Math.min(p.x,p.y,WORLD_SIZE-p.x,WORLD_SIZE-p.y); }

// ====== World grid ======
let grid = Array.from({length:TILE_N},()=>Array(TILE_N).fill(0));
function regenGrid(){
  grid = Array.from({length:TILE_N},()=>Array(TILE_N).fill(0));
  for(let y=0;y<TILE_N;y++){
    for(let x=0;x<TILE_N;x++){
      const nx=x/TILE_N, ny=y/TILE_N;
      const n1=(rand()*2-1)*0.3 + Math.sin(nx*8+seed%10)*0.1 + Math.cos(ny*7+seed%7)*0.1;
      const n2=(rand()*2-1)*0.15 + Math.sin((nx+ny)*10)*0.05;
      grid[y][x]=clamp(0.55 + n1 + n2, 0, 1);
    }
  }
}






let USE_COLORED_TILES = false;
if (typeof colorTiles !== 'undefined' && colorTiles) {
  USE_COLORED_TILES = !!colorTiles.checked;
  colorTiles.addEventListener('change', ()=>{ USE_COLORED_TILES = !!colorTiles.checked; });
}




function accessColor_COLORED(v){
  // Original coloured ramp (approx): teal ‚Üí green ‚Üí yellow ‚Üí orange-red
  if (v < 0.33){
    const t = v/0.33;
    const r = Math.round(47 + t*40), g = Math.round(208 + t*32), b = Math.round(163 - t*163);
    return `rgb(${r},${g},${b})`;
  } else if (v < 0.66){
    const t = (v-0.33)/0.33;
    const r = Math.round(87 + t*120), g = Math.round(240 - t*48), b = 0;
    return `rgb(${r},${g},${b})`;
  } else {
    const t = (v-0.66)/0.34;
    const r = Math.round(207 + t*48), g = Math.round(192 - t*192), b = 0;
    return `rgb(${r},${g},${b})`;
  }
}


function accessColor_GRAY(v){
  const g = Math.round(Math.max(0, Math.min(1, v)) * 128); // 0..128
  return `rgb(${g},${g},${g})`;
}


USE_COLORED_TILES = false;
if (typeof colorTiles !== 'undefined' && colorTiles) {
  USE_COLORED_TILES = !!colorTiles.checked;
  colorTiles.addEventListener('change', ()=>{ USE_COLORED_TILES = !!colorTiles.checked; });
}
function accessColor(v){
  return USE_COLORED_TILES ? accessColor_COLORED(v) : accessColor_GRAY(v);
}

function mixColor(c1,c2,t){
  const a=parseInt(c1.slice(1),16), b=parseInt(c2.slice(1),16);
  const r=(a>>16)&255, g=(a>>8)&255, bl=a&255;
  const r2=(b>>16)&255, g2=(b>>8)&255, bl2=b&255;
  const rr=Math.round(lerp(r,r2,t)), gg=Math.round(lerp(g,g2,t)), bb=Math.round(lerp(bl,bl2,t));
  return `rgb(${rr},${gg},${bb})`;
}
function makeStipple(alpha=0.08, density=0.25){
  const c=document.createElement('canvas'); c.width=c.height=32;
  const ctx=c.getContext('2d'); ctx.fillStyle='rgba(255,255,255,'+alpha+')';
  for(let i=0;i<32*32*density;i++) ctx.fillRect((rand()*32)|0,(rand()*32)|0,1,1);
  return ctx.createPattern(c,'repeat');
}
let stippleLo,stippleHi;
function regenStipple(){ stippleLo=makeStipple(0.08,0.12); stippleHi=makeStipple(0.07,0.35); markTileDirty(); }


function readPaletteFromCSS(){
  const root = document.documentElement;
  const styles = getComputedStyle(root);
  return {
    green: styles.getPropertyValue('--green').trim() || '#33FF33',
    orange: styles.getPropertyValue('--orange').trim() || '#E65C00'
  };
}
function applyRuntimePalette(){
  const pal = readPaletteFromCSS();
  if (typeof COLOR_GREEN !== 'undefined') COLOR_GREEN = pal.green;
  if (typeof COLOR_ORANGE !== 'undefined') COLOR_ORANGE = pal.orange;
}


// === Colorblind-safe palette helper (DSL-controllable) ===
if (typeof window.setCBPalette === 'undefined'){
  const __root = document.documentElement;
  const __styles0 = getComputedStyle(__root);
  const __USER_GREEN = (__styles0.getPropertyValue('--green').trim() || '#33FF33');
  const __USER_ORANGE = (__styles0.getPropertyValue('--orange').trim() || '#E65C00');
  const __CB_GREEN = '#009E73';  // Okabe‚ÄìIto bluish green
  const __CB_ORANGE = '#D55E00'; // Okabe‚ÄìIto vermillion

  window.setCBPalette = function(cbOn){
    if(cbOn){
      __root.style.setProperty('--green', __CB_GREEN);
      __root.style.setProperty('--orange', __CB_ORANGE);
    }else{
      __root.style.setProperty('--green', __USER_GREEN);
      __root.style.setProperty('--orange', __USER_ORANGE);
    }
    if (typeof applyRuntimePalette === 'function') applyRuntimePalette();
  };
}

// ====== Entities ======
const benches=[]; const obstacles=[]; const goals=[];
function randomPoint(margin=0){ return {x: margin + rand()*(WORLD_SIZE-2*margin), y: margin + rand()*(WORLD_SIZE-2*margin)} }
function spawnRandomGoal(){ goals.length=0; const p=randomPoint(800); goals.push({x:p.x,y:p.y,r:80,ttl:90+rand()*60}); }

// ====== Obstacles collision helpers ======

// === DSL helpers for obstacles ===
function addCircleObstacle(cx, cy, r, sides=32){
  const pts = [];
  for(let i=0;i<sides;i++){
    const t = (i/sides)*Math.PI*2;
    pts.push({x: cx + Math.cos(t)*r, y: cy + Math.sin(t)*r});
  }
  obstacles.push({ points: pts });
}

function wouldHitObstacle(nextPos){ for(const ob of obstacles){ if(pointInPoly(nextPos, ob.points)) return true; } return false; }
function segIntersect(p1,p2,q1,q2){
  function orient(a,b,c){ return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); }
  const o1=orient(p1,p2,q1), o2=orient(p1,p2,q2), o3=orient(q1,q2,p1), o4=orient(q1,q2,p2);
  if(((o1>0&&o2<0)||(o1<0&&o2>0)) && ((o3>0&&o4<0)||(o3<0&&o4>0))) return true;
  return false;
}
function reflectVector(vx,vy, nx,ny){
  const nlen=Math.hypot(nx,ny)||1; nx/=nlen; ny/=nlen;
  const dot=vx*nx+vy*ny;
  const rx=vx - 2*dot*nx, ry=vy - 2*dot*ny;
  return {x:rx,y:ry};
}
function polygonEdges(poly){
  const edges=[]; for(let i=0;i<poly.length;i++){ const a=poly[i], b=poly[(i+1)%poly.length]; edges.push([a,b]); } return edges;
}
function collideMoveBounce(bot, dx, dy){
  const p0={x:bot.pos.x, y:bot.pos.y}, p1={x:bot.pos.x+dx, y:bot.pos.y+dy};
  let hitInfo=null;
  for(const ob of obstacles){
    if(pointInPoly(p1, ob.points)){
      let best=null,bd=1e9;
      for(const [a,b] of polygonEdges(ob.points)){
        const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
        const d=(p1.x-mx)*(p1.x-mx)+(p1.y-my)*(p1.y-my);
        if(d<bd){ bd=d; best=[a,b]; }
      }
      hitInfo={edge:best, ob};
      break;
    }
    for(const [a,b] of polygonEdges(ob.points)){
      if(segIntersect(p0,p1,a,b)){ hitInfo={edge:[a,b], ob}; break; }
    }
    if(hitInfo) break;
  }
  if(!hitInfo){ bot.pos = p1; return; }
  let vx=dx, vy=dy;
  if(hitInfo.edge){
    const [a,b]=hitInfo.edge;
    let nx=-(b.y-a.y), ny=(b.x-a.x);
    if(vx*nx+vy*ny>0){ nx=-nx; ny=-ny; }
    const r=reflectVector(vx,vy,nx,ny);
    const scale = 0.5;
    const pr={x:bot.pos.x + r.x*scale, y: bot.pos.y + r.y*scale};
    if(!wouldHitObstacle(pr) && !pointInPoly(pr, hitInfo.ob.points)){
      bot.pos = pr;
    }
    bot.heading = Math.atan2(r.y, r.x);
  }else{
    bot.heading = Math.atan2(-vy, -vx);
    const pr={x:bot.pos.x - vx*0.5, y: bot.pos.y - vy*0.5};
    if(!wouldHitObstacle(pr)) bot.pos = pr;
  }
}

// ====== Bots base ======
class Bot{
  constructor(x,y,color){
    this.pos={x:x, y:y};
    this.heading=Math.random()*TWO_PI;
    this.speed=90;
    this.color=color;
    this.fatigue=0;
    this.state='MOVE';
    this.restLeft=0;
    this.restSeconds=15;
    this.trail=[{x:x,y:y}];
    this.trailEvery=3; this._trailAcc=0;
    this.targetBench=null;
  }
  tileAccess(){ const gx=clamp(Math.floor(this.pos.x/TILE_SIZE),0,TILE_N-1); const gy=clamp(Math.floor(this.pos.y/TILE_SIZE),0,TILE_N-1); return grid[gy][gx]; }
  nearestBench(){ if(benches.length===0) return null; let best=null, bd=1e9; for(const b of benches){ const d=dist(this.pos,b); if(d<bd){bd=d; best=b} } return {bench:best, d:bd}; }
  
    addTrail(p){
      const last=this.trail[this.trail.length-1];
      // Distance accumulator controls sampling density
      this._trailAcc+=dist(p,last);
      // Dynamic spacing: fewer points when lots of bots or zoomed out
      let spacing = this.trailEvery;
      if(typeof window !== 'undefined'){
        const botCount = (window.greens?greens.length:0) + (window.oranges?oranges.length:0);
        if(botCount>40) spacing *= 1.5;
        if(botCount>80) spacing *= 2.0;
      }
      if(this._trailAcc>=spacing){
        // Simple decimation: if the last 2 segments are nearly collinear, drop the middle to reduce path nodes
        const L=this.trail.length;
        if(L>=2){
          const a=this.trail[L-2], b=last, c=p;
          const abx=b.x-a.x, aby=b.y-a.y, bcx=c.x-b.x, bcy=c.y-b.y;
          const cross=Math.abs(abx*bcy - aby*bcx);
          if(cross<0.01){ this.trail[L-1]={x:c.x,y:c.y}; } else { this.trail.push({x:p.x,y:p.y}); }
        }else{
          this.trail.push({x:p.x,y:p.y});
        }
        this._trailAcc=0;
        // Limit total points to avoid unbounded growth
        const MAXP = (window.TRAIL_MAXP==null?Number.POSITIVE_INFINITY:window.TRAIL_MAXP);
        if(Number.isFinite(MAXP) && this.trail.length>MAXP){ this.trail.splice(0, this.trail.length-MAXP); }
      }
    }

  drawTrail(ctx,a=0.5){ if(this.trail.length<2) return; ctx.save(); ctx.globalAlpha=a; ctx.lineWidth=RUNTIME_TRAIL_LINEWIDTH; ctx.strokeStyle=this.color; ctx.beginPath(); ctx.moveTo(this.trail[0].x,this.trail[0].y); for(let i=1;i<this.trail.length;i++) ctx.lineTo(this.trail[i].x,this.trail[i].y); ctx.stroke(); ctx.restore(); }
  stepCommon(dt){
    const {x,y}=this.pos;
    if(!WRAP){
      let rx=0,ry=0;
      if(x<EDGE_REPEL_DIST) rx += (EDGE_REPEL_DIST-x)/EDGE_REPEL_DIST;
      if(y<EDGE_REPEL_DIST) ry += (EDGE_REPEL_DIST-y)/EDGE_REPEL_DIST;
      if(x>WORLD_SIZE-EDGE_REPEL_DIST) rx -= (x-(WORLD_SIZE-EDGE_REPEL_DIST))/EDGE_REPEL_DIST;
      if(y>WORLD_SIZE-EDGE_REPEL_DIST) ry -= (y-(WORLD_SIZE-EDGE_REPEL_DIST))/EDGE_REPEL_DIST;
      if(rx||ry){ const ang=Math.atan2(ry,rx); this.heading = angleLerp(this.heading, ang, 0.12); }
      this.pos.x=clamp(this.pos.x,0,WORLD_SIZE); this.pos.y=clamp(this.pos.y,0,WORLD_SIZE);
      if(this.pos.x<=0||this.pos.x>=WORLD_SIZE) this.heading=Math.PI - this.heading;
      if(this.pos.y<=0||this.pos.y>=WORLD_SIZE) this.heading=-this.heading;
    }else{
      if(this.pos.x<0) this.pos.x+=WORLD_SIZE; if(this.pos.x>WORLD_SIZE) this.pos.x-=WORLD_SIZE;
      if(this.pos.y<0) this.pos.y+=WORLD_SIZE; if(this.pos.y>WORLD_SIZE) this.pos.y-=WORLD_SIZE;
    }
  }
}

class GreenBot extends Bot{
  constructor(x,y){
    super(x,y,COLOR_GREEN);
    this.speed=85;
    this.wobbleAmp=0.6; this.wobbleFreq=1.2;
    this.leftBias=0.025; this.turnLeft=2.2; this.turnRight=1.3;
    this.avoid=0.25; this.hardRepel=2.0; this.goalWeight=1.0;
    this.fatigueRate = BASE_FATIGUE.GREEN * FATIGUE_SCALE;
    this.asymmetry=0.4;
    this.time=0;
  }
  update(dt){
    this.time+=dt;
    if(this.state==='REST'){ this.restLeft-=dt; if(this.restLeft<=0){ this.state='MOVE'; this.fatigue=0; this.targetBench=null; } return; }

    if(this.fatigue>=1 && this.state!=='TO_BENCH'){
      if(benches.length>0){ const nb=this.nearestBench(); if(nb){ this.state='TO_BENCH'; this.targetBench=nb.bench; } }
      else { this.state='REST'; this.restLeft=this.restSeconds; }
    }

    if(this.state==='TO_BENCH' && this.targetBench){
      const wobble = Math.sin(this.time*this.wobbleFreq*TWO_PI)*this.wobbleAmp*2; // double wobble en route
      const leftBiasStep = (this.leftBias!=null?this.leftBias:0.005);
      const angBench = Math.atan2(this.targetBench.y-this.pos.y, this.targetBench.x-this.pos.x);
      let desiredHeading = angleLerp(this.heading, angBench, 0.6);
      desiredHeading += wobble*dt - leftBiasStep*dt; // always pull left
      const nextPos={x:this.pos.x+Math.cos(this.heading)*this.speed*dt*0.5, y:this.pos.y+Math.sin(this.heading)*this.speed*dt*0.5};
      if(OBST_BLOCK_GREEN && wouldHitObstacle(nextPos)) desiredHeading = this.heading - 1.2*dt;
      this.applyTurnToward(desiredHeading, dt, 1.0);
      this.advance(dt*0.5);
      if(this.targetBench && dist(this.pos,this.targetBench)<20){
        this.state='REST'; this.restLeft=this.restSeconds; this.targetBench=null;
      }
      this.stepCommon(dt); this.addTrail(this.pos); return;
    }

    // Normal movement
    const leftBiasStep = (this.leftBias!=null?this.leftBias:0.005);
    let desiredHeading=this.heading;
    const wobble=Math.sin(this.time*this.wobbleFreq*TWO_PI)*this.wobbleAmp;
    desiredHeading += wobble*dt - leftBiasStep*dt; // always pull left

    // local sampling by accessibility
    const s=150;
    const left=sampleAccess(this.pos.x+Math.cos(this.heading-Math.PI/2)*s*0.9, this.pos.y+Math.sin(this.heading-Math.PI/2)*s*0.9);
    const right=sampleAccess(this.pos.x+Math.cos(this.heading+Math.PI/2)*s*0.9, this.pos.y+Math.sin(this.heading+Math.PI/2)*s*0.9);
    desiredHeading += ((left>right?-1:1) * Math.abs(left-right) * 0.8) * dt;

    const here=this.tileAccess();
    if(here < this.avoid){
      let bestAng=this.heading, bestVal=-1;
      for(let k=0;k<8;k++){
        const ang=this.heading + k*(TWO_PI/8);
        const v=sampleAccess(this.pos.x+Math.cos(ang)*s, this.pos.y+Math.sin(ang)*s);
        if(v>bestVal){bestVal=v; bestAng=ang}
      }
      desiredHeading = angleLerp(this.heading,bestAng,clamp((this.avoid-here)*this.hardRepel,0.5,1.0));
    }

    const g=nearestGoal(this.pos);
    if(g){
      const ang=Math.atan2(g.y-this.pos.y,g.x-this.pos.x);
      desiredHeading = angleLerp(desiredHeading, ang, clamp(0.25*this.goalWeight,0,0.8));
      if(dist(this.pos,g)<(g.r||80)) g._reached=true;
    }

    const nextPos={x:this.pos.x+Math.cos(this.heading)*this.speed*dt, y:this.pos.y+Math.sin(this.heading)*this.speed*dt};
    if(OBST_BLOCK_GREEN && wouldHitObstacle(nextPos)) desiredHeading=this.heading - 1.2*dt;

    this.applyTurnToward(desiredHeading, dt, 1.0);
    this.advance(dt);

    const turnCost=Math.abs(angleWrap(desiredHeading-this.heading));
    this.fatigue=Math.min(1.2, this.fatigue + (this.fatigueRate*(1+this.asymmetry) + turnCost*0.02)*dt);

    this.stepCommon(dt); this.addTrail(this.pos);
  }
  applyTurnToward(targetAngle, dt, strength=1){
    let d=angleWrap(targetAngle-this.heading);
    const maxLeft=this.turnLeft*dt*strength, maxRight=this.turnRight*dt*strength;
    if(d<0) d=Math.max(d,-maxLeft); else d=Math.min(d,maxRight);
    this.heading=angleWrap(this.heading+d);
  }
  advance(dt){
    const dx=Math.cos(this.heading)*this.speed*dt;
    const dy=Math.sin(this.heading)*this.speed*dt;
    if(OBST_BLOCK_GREEN){ collideMoveBounce(this, dx, dy); } else { this.pos.x+=dx; this.pos.y+=dy; }
  }
}

class OrangeBot extends Bot{
  constructor(x,y){
    super(x,y,COLOR_ORANGE);
    this.speed=95; this.jitter=0.9; this.turn=1.8; this.goalWeight=0.35;
    this.fatigueRate = BASE_FATIGUE.ORANGE * FATIGUE_SCALE;
    this.time=0;
    this.leftBias=0; // generally none
  }
  update(dt){
    this.time+=dt;
    if(this.state==='REST'){ this.restLeft-=dt; if(this.restLeft<=0){ this.state='MOVE'; this.fatigue=0; } return; }

    if(this.fatigue>=1 && this.state!=='TO_BENCH'){
      if(benches.length>0){ const nb=this.nearestBench(); if(nb){ this.state='TO_BENCH'; this.targetBench=nb.bench; } }
      else { this.state='REST'; this.restLeft=this.restSeconds; }
    }

    if(this.state==='TO_BENCH' && this.targetBench){
      const ang=Math.atan2(this.targetBench.y-this.pos.y,this.targetBench.x-this.pos.x);
      this.heading = angleLerp(this.heading, ang, 0.25);
      this.advance(dt*0.5);
      if(this.targetBench && dist(this.pos,this.targetBench)<20){ this.state='REST'; this.restLeft=this.restSeconds; this.targetBench=null; }
      this.stepCommon(dt); this.addTrail(this.pos); return;
    }

    const noise=(rand()*2-1) * (this.jitter) * dt;
    this.heading=angleWrap(this.heading + clamp(noise, -this.turn*dt, this.turn*dt));

    const g=nearestGoal(this.pos);
    if(g){
      const ang=Math.atan2(g.y-this.pos.y,g.x-this.pos.x);
      this.heading=angleLerp(this.heading, ang, clamp(0.15*this.goalWeight,0,0.6));
      if(dist(this.pos,g)<(g.r||80)) g._reached=true;
    }

    this.advance(dt);
    this.fatigue=Math.min(1.2,this.fatigue + this.fatigueRate*dt);

    this.stepCommon(dt); this.addTrail(this.pos);
  }
  advance(dt){
    const dx=Math.cos(this.heading)*this.speed*dt;
    const dy=Math.sin(this.heading)*this.speed*dt;
    if(OBST_BLOCK_ORANGE){ collideMoveBounce(this, dx, dy); } else { this.pos.x+=dx; this.pos.y+=dy; }
  }
}

function sampleAccess(x,y){
  x=clamp(x,0,WORLD_SIZE-1); y=clamp(y,0,WORLD_SIZE-1);
  const gx=clamp(Math.floor(x/TILE_SIZE),0,TILE_N-1);
  const gy=clamp(Math.floor(y/TILE_SIZE),0,TILE_N-1);
  return grid[gy][gx];
}
function nearestGoal(p){ if(goals.length===0) return null; let best=null,bd=1e9; for(const g of goals){ const d=dist(p,g); if(d<bd){bd=d; best=g} } return best; }

// ====== Camera & canvases ======
const main=document.getElementById('main'), mainCtx=main.getContext('2d');
const minimap=document.getElementById('minimap'), miniCtx=minimap.getContext('2d');
const holder=document.getElementById('canvas-holder');
const camera={x: WORLD_SIZE/2, y: WORLD_SIZE/2, zoom: 0.35, follow:'GREEN'};
  // --- Offscreen tile layer buffer (re-render only when camera/zoom/overlay changes) ---
  let tileBuffer = (typeof OffscreenCanvas!=='undefined') ? new OffscreenCanvas(1,1) : document.createElement('canvas');
  let tileCtx = tileBuffer.getContext('2d');
  let tileDirty = true;
  let lastTileCam = { x: null, y: null, zoom: null, showAccess: null, worldSize: null, tileN: null };

  function ensureTileBufferSize(){
    const w = main.width, h = main.height;
    if(tileBuffer.width !== w || tileBuffer.height !== h){
      tileBuffer.width = w; tileBuffer.height = h;
      tileDirty = true;
    }
  }
  function markTileDirty(){ tileDirty = true; }

  function renderTilesToBuffer(){
    ensureTileBufferSize();
    tileCtx.clearRect(0,0,tileBuffer.width,tileBuffer.height);
    tileCtx.save();
    worldToView(tileCtx, camera);
    const w=main.width,h=main.height;
    const x0=clamp(Math.floor((camera.x-w/(2*camera.zoom))/TILE_SIZE),0,TILE_N-1);
    const y0=clamp(Math.floor((camera.y-h/(2*camera.zoom))/TILE_SIZE),0,TILE_N-1);
    const x1=clamp(Math.floor((camera.x+w/(2*camera.zoom))/TILE_SIZE)+1,0,TILE_N-1);
    const y1=clamp(Math.floor((camera.y+h/(2*camera.zoom))/TILE_SIZE)+1,0,TILE_N-1);
    for(let gy=y0;gy<=y1;gy++){
      for(let gx=x0;gx<=x1;gx++){
        const v=grid[gy][gx];
        tileCtx.fillStyle=accessColor(v);
        const x=gx*TILE_SIZE,y=gy*TILE_SIZE;
        tileCtx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
        tileCtx.save();
        tileCtx.fillStyle = v>0.6?stippleHi:stippleLo;
        tileCtx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
        tileCtx.restore();
        if(showAccess.checked){
          tileCtx.save();
          tileCtx.strokeStyle='rgba(255,255,255,0.08)';
          tileCtx.lineWidth=1;
          tileCtx.strokeRect(x+0.5,y+0.5,TILE_SIZE-1,TILE_SIZE-1);
          tileCtx.fillStyle='rgba(255,255,255,0.5)';
          tileCtx.font=`${Math.max(16,Math.min(48,TILE_SIZE*0.2))}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
          tileCtx.textAlign='center';
          tileCtx.textBaseline='middle';
          tileCtx.fillText(v.toFixed(2), x+TILE_SIZE/2, y+TILE_SIZE/2);
          tileCtx.restore();
        }
      }
    }
    tileCtx.restore();
    lastTileCam = { x: camera.x, y: camera.y, zoom: camera.zoom, showAccess: showAccess.checked, worldSize: WORLD_SIZE, tileN: TILE_N };
    tileDirty = false;
  }

function resize(){ main.width = holder.clientWidth - 372; main.height = holder.clientHeight - 20; ensureTileBufferSize(); markTileDirty(); }
window.addEventListener('resize', resize); resize();
let dragging=false, lastMouse=null;
main.addEventListener('mousedown',(e)=>{ if(camera.follow!=='NONE') return; dragging=true; lastMouse={x:e.clientX, y:e.clientY}; });
window.addEventListener('mouseup',()=>dragging=false);
window.addEventListener('mousemove',(e)=>{ if(dragging && lastMouse){ const dx=e.clientX-lastMouse.x, dy=e.clientY-lastMouse.y; camera.x -= dx/camera.zoom; camera.y -= dy/camera.zoom; camera.x=clamp(camera.x,0,WORLD_SIZE); camera.y=clamp(camera.y,0,WORLD_SIZE); lastMouse={x:e.clientX, y:e.clientY}; } });
main.addEventListener('wheel',(e)=>{ e.preventDefault(); const factor=Math.exp(-e.deltaY*0.001); camera.zoom=clamp(camera.zoom*factor, 0.1, 1.5); }, {passive:false});
minimap.addEventListener('click',(e)=>{ const rect=minimap.getBoundingClientRect(); const sx=(e.clientX-rect.left)/rect.width; const sy=(e.clientY-rect.top)/rect.height; camera.x=sx*WORLD_SIZE; camera.y=sy*WORLD_SIZE; });

// ====== UI elements ======
const greenMinus=document.getElementById('greenMinus');
const trailAlpha=document.getElementById('trailAlpha'); const trailAlphaVal=document.getElementById('trailAlphaVal'); const greenPlus=document.getElementById('greenPlus'); const orangeMinus=document.getElementById('orangeMinus'); const orangePlus=document.getElementById('orangePlus');
const speedSel=document.getElementById('speed'); const followSel=document.getElementById('followSel'); const showTrails=document.getElementById('showTrails'); const showAccess=document.getElementById('showAccess'); const cbSafe=document.getElementById('cbSafe'); const showGoals=document.getElementById('showGoals'); const avoidSlider=document.getElementById('avoid'); const avoidVal=document.getElementById('avoidVal'); const trailW=document.getElementById('trailW'); const trailWVal=document.getElementById('trailWVal'); const wobAmp=document.getElementById('wobAmp'); const wobAmpVal=document.getElementById('wobAmpVal'); const leftBias=document.getElementById('leftBias'); const leftBiasVal=document.getElementById('leftBiasVal'); const fatigueScale=document.getElementById('fatigueScale'); const fatigueScaleVal=document.getElementById('fatigueScaleVal'); const greenCount=document.getElementById('greenCount'); const orangeCount=document.getElementById('orangeCount'); const applyCounts=document.getElementById('applyCounts'); const pauseBtn=document.getElementById('pause'); const resetBtn=document.getElementById('reset'); const saveBtn=document.getElementById('saveTrails'); const exportTiles=document.getElementById('exportTiles'); const exportTileValues=document.getElementById('exportTileValues'); const statsEl=document.getElementById('stats'); const dslTA=document.getElementById('dsl'); const runDSLBtn=document.getElementById('runDSL'); const clearDSLBtn=document.getElementById('clearDSL'); const dslStatus=document.getElementById('dslStatus');
followSel.addEventListener('change',()=>{ camera.follow=followSel.value; });
avoidSlider.addEventListener('input',()=>{ avoidVal.textContent=(+avoidSlider.value).toFixed(2); greens.forEach(g=>g.avoid=+avoidSlider.value); });
  showAccess.addEventListener('change', ()=>{ markTileDirty(); });
  showGoals.addEventListener('change', ()=>{});
let paused=false; pauseBtn.addEventListener('click',()=>{ paused=!paused; pauseBtn.textContent=paused?'‚ñ∂ Resume':'‚è∏ Pause'; });
resetBtn.addEventListener('click',()=>{ resetWorld(true); });
clearDSLBtn.addEventListener('click',()=>{ dslTA.value=''; dslStatus.textContent='Cleared.'; });
saveBtn.addEventListener('click',()=>{ saveTrailsPNG(EXPORT_SIZE, undefined, RUNTIME_TRAIL_LINEWIDTH); });

document.addEventListener('keydown',(e)=>{
  if(e.key===' ' || e.key==='p' || e.key==='P'){ e.preventDefault(); paused=!paused; pauseBtn.textContent=paused?'‚ñ∂ Resume':'‚è∏ Pause'; }
});


trailW.addEventListener('input',()=>{ RUNTIME_TRAIL_LINEWIDTH=+trailW.value; trailWVal.textContent=trailW.value; EXPORT_LINEWIDTH=RUNTIME_TRAIL_LINEWIDTH; });

/* Colorblind-safe palette toggle */
if (typeof cbSafe !== 'undefined' && cbSafe){
  // Remember user's original values from CSS at load
  const root = document.documentElement;
  const styles0 = getComputedStyle(root);
  const USER_GREEN = (styles0.getPropertyValue('--green').trim() || '#33FF33');
  const USER_ORANGE = (styles0.getPropertyValue('--orange').trim() || '#E65C00');

  // Okabe‚ÄìIto colorblind-safe alternatives
  const CB_GREEN = '#009E73';   // bluish green
  const CB_ORANGE = '#D55E00';  // vermillion (distinct from USER_ORANGE)

  // Initialize based on current checkbox state
  function setPalette(cb){
    if(cb){
      root.style.setProperty('--green', CB_GREEN);
      root.style.setProperty('--orange', CB_ORANGE);
    }else{
      root.style.setProperty('--green', USER_GREEN);
      root.style.setProperty('--orange', USER_ORANGE);
    }
    applyRuntimePalette();
  }
  setPalette(cbSafe.checked);
  cbSafe.addEventListener('change', ()=> setPalette(cbSafe.checked));
}

// Trail Alpha (opacity) slider
if (typeof trailAlpha !== 'undefined' && trailAlpha) {
  // initialize display
  trailAlpha.value = TRAIL_ALPHA;
  trailAlphaVal.textContent = Math.round(TRAIL_ALPHA*100) + '%';
  trailAlpha.addEventListener('input', ()=>{
    TRAIL_ALPHA = +trailAlpha.value;
    trailAlphaVal.textContent = Math.round(TRAIL_ALPHA*100) + '%';
  });
}

wobAmp.addEventListener('input',()=>{ const v=+wobAmp.value; wobAmpVal.textContent=v.toFixed(2); greens.forEach(g=>g.wobbleAmp=v); });
leftBias.addEventListener('input',()=>{ const v=+leftBias.value; leftBiasVal.textContent=v.toFixed(3); greens.forEach(g=>g.leftBias=v); });
fatigueScale.addEventListener('input',()=>{
  FATIGUE_SCALE = +fatigueScale.value;
  fatigueScaleVal.textContent = FATIGUE_SCALE.toFixed(2) + '√ó';
  greens.forEach(g=>{ if(!g._fatigueLocked) g.fatigueRate = BASE_FATIGUE.GREEN * FATIGUE_SCALE; });
  oranges.forEach(o=>{ if(!o._fatigueLocked) o.fatigueRate = BASE_FATIGUE.ORANGE * FATIGUE_SCALE; });
});

function applyBotCounts(){
  const g = Math.max(0, Math.min(200, parseInt(greenCount.value||'0')));
  const o = Math.max(0, Math.min(200, parseInt(orangeCount.value||'0')));
  spawnGreens(g);
  spawnOranges(o);
  if(greens.length){ camera.x=greens[0].pos.x; camera.y=greens[0].pos.y; }
  avoidSlider.value=greens[0]?.avoid ?? avoidSlider.value;
  avoidVal.textContent=(greens[0]?.avoid ?? +avoidSlider.value).toFixed(2);
}
applyCounts.addEventListener('click', applyBotCounts);
greenCount.addEventListener('keydown', (e)=>{ if(e.key==='Enter') applyBotCounts(); });
orangeCount.addEventListener('keydown', (e)=>{ if(e.key==='Enter') applyBotCounts(); });
greenMinus.addEventListener('click',()=>{ greenCount.value=Math.max(0, parseInt(greenCount.value||'0')-1); applyBotCounts(); });
greenPlus.addEventListener('click',()=>{ greenCount.value=Math.min(200, parseInt(greenCount.value||'0')+1); applyBotCounts(); });
orangeMinus.addEventListener('click',()=>{ orangeCount.value=Math.max(0, parseInt(orangeCount.value||'0')-1); applyBotCounts(); });
orangePlus.addEventListener('click',()=>{ orangeCount.value=Math.min(200, parseInt(orangeCount.value||'0')+1); applyBotCounts(); });

runDSLBtn.addEventListener('click',()=>{ runDSL(dslTA.value); });

// ====== Save trails (uses runtime width by default; DSL can override) ======

/** Draw accessibility tiles to an export canvas covering the full world. */
function drawTilesExport(ctx, scale){
  // full grid without camera culling
  for(let gy=0; gy<TILE_N; gy++){
    for(let gx=0; gx<TILE_N; gx++){
      const v = grid[gy][gx];
      const x = gx*TILE_SIZE*scale;
      const y = gy*TILE_SIZE*scale;
      const s = TILE_SIZE*scale;
      // base grayscale
      ctx.fillStyle = accessColor_GRAY(v);
      ctx.fillRect(x, y, s, s);
      // coloured overlay at 90% alpha when toggle is on
      if ((typeof USE_COLORED_TILES!=='undefined' && USE_COLORED_TILES) || (typeof colorTiles!=='undefined' && colorTiles && colorTiles.checked)){
        ctx.save(); const __prev=ctx.globalAlpha; ctx.globalAlpha=0.9;
        ctx.fillStyle = accessColor_COLORED(v);
        ctx.fillRect(x, y, s, s);
        ctx.globalAlpha=__prev; ctx.restore();
      }
      // stipple overlay like main view tiles
      ctx.save();
      ctx.fillStyle = v>0.6 ? stippleHi : stippleLo;
      ctx.fillRect(x, y, s, s);
      ctx.restore();
    }
  }
}

function saveTrailsPNG(size=10000, filename='dual-bot-trails.png', lineWidth=RUNTIME_TRAIL_LINEWIDTH){
  const EXPORT = size|0;
  const scale = EXPORT / WORLD_SIZE;
  const c = document.createElement('canvas');
  c.width = c.height = EXPORT;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, EXPORT, EXPORT);
  ctx.globalAlpha = TRAIL_ALPHA;
  
// Optionally draw accessibility tiles beneath trails
if (typeof exportTiles !== 'undefined' && exportTiles && exportTiles.checked){
  const prevAlpha = ctx.globalAlpha;
  ctx.globalAlpha = 1;
  drawTilesExport(ctx, scale);
  ctx.globalAlpha = prevAlpha;
}

  ctx.lineWidth = lineWidth;

  ctx.strokeStyle = COLOR_GREEN;
  ctx.beginPath();
  for(const bot of greens){
    for(let i=1;i<bot.trail.length;i++){
      const a=bot.trail[i-1], b=bot.trail[i];
      ctx.moveTo(a.x*scale, a.y*scale);
      ctx.lineTo(b.x*scale, b.y*scale);
    }
  }
  ctx.stroke();

  ctx.strokeStyle = COLOR_ORANGE;
  ctx.beginPath();
  for(const bot of oranges){
    for(let i=1;i<bot.trail.length;i++){
      const a=bot.trail[i-1], b=bot.trail[i];
      ctx.moveTo(a.x*scale, a.y*scale);
      ctx.lineTo(b.x*scale, b.y*scale);
    }
  }
  ctx.stroke();

  const url = c.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url; a.download = filename || 'dual-bot-trails.png'; a.click();
}

// ====== World state & spawns ======
let greens=[], oranges=[];
function spawnGreens(n){ greens=[]; for(let i=0;i<n;i++){ const p=randomPoint(800); const g=new GreenBot(p.x,p.y); g._index=i; greens.push(g); } greenCount.value=String(greens.length); }
function spawnOranges(n){ oranges=[]; for(let i=0;i<n;i++){ const p=randomPoint(800); const o=new OrangeBot(p.x,p.y); o._index=i; oranges.push(o); } orangeCount.value=String(oranges.length); }

function resetWorld(full=false){
  benches.length=0; obstacles.length=0; /* no default obstacle */ goals.length=0; /* single-goal mode enforced */
  if(full){ seed=Math.floor(Math.random()*1e9); rand=mulberry32(seed); }
  regenGrid(); regenStipple(); TILE_SIZE=WORLD_SIZE/TILE_N;
  spawnGreens(1); spawnOranges(1);
  applyRuntimePalette();
  greenCount.value=String(greens.length); orangeCount.value=String(oranges.length);
  if(greens.length){ camera.x=greens[0].pos.x; camera.y=greens[0].pos.y; }
  avoidSlider.value=greens[0].avoid; avoidVal.textContent=greens[0].avoid.toFixed(2);
}
regenGrid(); regenStipple(); spawnGreens(1); spawnOranges(1); greenCount.value=String(greens.length); orangeCount.value=String(oranges.length);

// ====== Rendering ======
function worldToView(ctx,cam){ const w=main.width,h=main.height; ctx.translate(w/2,h/2); ctx.scale(cam.zoom,cam.zoom); ctx.translate(-cam.x,-cam.y); }
function drawTiles(ctx,cam){
  const w=main.width,h=main.height; ctx.save(); worldToView(ctx,cam);
  const x0=clamp(Math.floor((cam.x-w/(2*cam.zoom))/TILE_SIZE),0,TILE_N-1);
  const y0=clamp(Math.floor((cam.y-h/(2*cam.zoom))/TILE_SIZE),0,TILE_N-1);
  const x1=clamp(Math.floor((cam.x+w/(2*cam.zoom))/TILE_SIZE)+1,0,TILE_N-1);
  const y1=clamp(Math.floor((cam.y+h/(2*cam.zoom))/TILE_SIZE)+1,0,TILE_N-1);
  for(let gy=y0;gy<=y1;gy++){
    for(let gx=x0;gx<=x1;gx++){
      const v=grid[gy][gx];
      const x=gx*TILE_SIZE,y=gy*TILE_SIZE;
      // base grayscale
      ctx.fillStyle=accessColor_GRAY(v);
      ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
      // coloured overlay at 90% alpha when toggle is on
      if ((typeof USE_COLORED_TILES!=='undefined' && USE_COLORED_TILES) || (typeof colorTiles!=='undefined' && colorTiles && colorTiles.checked)){
        ctx.save(); const __prev=ctx.globalAlpha; ctx.globalAlpha=0.9;
        ctx.fillStyle=accessColor_COLORED(v);
        ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
        ctx.globalAlpha=__prev; ctx.restore();
      }
      // stipple overlay
      ctx.save(); ctx.fillStyle = v>0.6?stippleHi:stippleLo; ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE); ctx.restore();
      if(showAccess.checked){
        ctx.save();
        ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.strokeRect(x+0.5,y+0.5,TILE_SIZE-1,TILE_SIZE-1);
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.font = `${Math.max(16, Math.min(48, TILE_SIZE*0.2))}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;

        ctx.fillText(v.toFixed(2), x+TILE_SIZE/2, y+TILE_SIZE/2);
        ctx.restore();
      }
    }
  }
  ctx.restore();
}
function drawBot(ctx,bot,limping){
  ctx.save(); ctx.translate(bot.pos.x,bot.pos.y); ctx.rotate(bot.heading);
  if(limping){ const sway=Math.sin(performance.now()/1000*6)*4; ctx.translate(0,sway); }
  ctx.fillStyle=bot.color; ctx.globalAlpha=0.95; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=1; ctx.strokeStyle='#ffffff88'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(16,0); ctx.stroke();
  ctx.restore();
}
function drawEntities(ctx,cam){
  ctx.save(); worldToView(ctx,cam);
  if(showTrails.checked){ for(const g of greens) g.drawTrail(ctx,TRAIL_ALPHA); for(const o of oranges) o.drawTrail(ctx,TRAIL_ALPHA); }
  for(const ob of obstacles){
    ctx.save(); ctx.fillStyle='rgba(255,77,179,0.12)'; ctx.strokeStyle='rgba(255,77,179,0.7)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(ob.points[0].x,ob.points[0].y); for(let i=1;i<ob.points.length;i++) ctx.lineTo(ob.points[i].x,ob.points[i].y); ctx.closePath();
    ctx.fill(); ctx.stroke(); ctx.restore();
  }
  for(const b of benches){
    ctx.save(); ctx.fillStyle='rgba(88,166,255,0.8)'; ctx.strokeStyle='rgba(22,46,76,0.9)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(b.x,b.y,10,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();
  }
  const t=performance.now()/1000;
  if(showGoals.checked){
    for(const g of goals){
      const ring=0.5+0.5*Math.sin(t*2+g.x*0.001+g.y*0.001); const r=(g.r||80)+ring*6;
      ctx.save(); ctx.strokeStyle='rgba(125,211,252,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(g.x,g.y,r,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(g.x,g.y,r*0.55,0,Math.PI*2); ctx.stroke(); ctx.restore();
    }
  }
  for(const g of greens) drawBot(ctx,g,true);
  for(const o of oranges) drawBot(ctx,o,false);
  ctx.restore();
}
function drawMinimap(){
  const w=minimap.width,h=minimap.height; miniCtx.clearRect(0,0,w,h);
  for(let gy=0;gy<TILE_N;gy++){ for(let gx=0;gx<TILE_N;gx++){ miniCtx.fillStyle=accessColor(grid[gy][gx]); const x=Math.floor(gx*(w/TILE_N)), y=Math.floor(gy*(h/TILE_N)); miniCtx.fillRect(x,y,Math.ceil(w/TILE_N),Math.ceil(h/TILE_N)); } }
  miniCtx.save(); miniCtx.strokeStyle='rgba(255,77,179,0.8)'; miniCtx.fillStyle='rgba(255,77,179,0.15)'; miniCtx.lineWidth=1;
  for(const ob of obstacles){ miniCtx.beginPath(); miniCtx.moveTo(ob.points[0].x/WORLD_SIZE*w,ob.points[0].y/WORLD_SIZE*h); for(let i=1;i<ob.points.length;i++) miniCtx.lineTo(ob.points[i].x/WORLD_SIZE*w,ob.points[i].y/WORLD_SIZE*h); miniCtx.closePath(); miniCtx.fill(); miniCtx.stroke(); }
  miniCtx.restore();
  miniCtx.fillStyle='rgba(88,166,255,0.95)'; for(const b of benches){ miniCtx.fillRect(b.x/WORLD_SIZE*w-2,b.y/WORLD_SIZE*h-2,4,4); }
  if(showGoals.checked){ miniCtx.strokeStyle='rgba(125,211,252,0.95)'; for(const g of goals){ const x=g.x/WORLD_SIZE*w, y=g.y/WORLD_SIZE*h; miniCtx.beginPath(); miniCtx.arc(x,y,4,0,Math.PI*2); miniCtx.stroke(); } }
  if(showTrails.checked){
    miniCtx.globalAlpha=TRAIL_ALPHA; miniCtx.lineWidth=1;
    miniCtx.strokeStyle=COLOR_GREEN;
    miniCtx.beginPath(); for(const bot of greens){ for(let i=1;i<bot.trail.length;i++){ const a=bot.trail[i-1], b=bot.trail[i]; miniCtx.moveTo(a.x/WORLD_SIZE*w,a.y/WORLD_SIZE*h); miniCtx.lineTo(b.x/WORLD_SIZE*w,b.y/WORLD_SIZE*h);} } miniCtx.stroke();
    miniCtx.strokeStyle=COLOR_ORANGE;
    miniCtx.beginPath(); for(const bot of oranges){ for(let i=1;i<bot.trail.length;i++){ const a=bot.trail[i-1], b=bot.trail[i]; miniCtx.moveTo(a.x/WORLD_SIZE*w,a.y/WORLD_SIZE*h); miniCtx.lineTo(b.x/WORLD_SIZE*w,b.y/WORLD_SIZE*h);} } miniCtx.stroke();
    miniCtx.globalAlpha=1;
  }
  miniCtx.fillStyle=COLOR_GREEN; for(const g of greens){ const x=g.pos.x/WORLD_SIZE*w, y=g.pos.y/WORLD_SIZE*h; miniCtx.fillRect(x-2,y-2,4,4); }
  miniCtx.fillStyle=COLOR_ORANGE; for(const o of oranges){ const x=o.pos.x/WORLD_SIZE*w, y=o.pos.y/WORLD_SIZE*h; miniCtx.fillRect(x-2,y-2,4,4); }
  const vw=main.width/camera.zoom/WORLD_SIZE*w; const vh=main.height/camera.zoom/WORLD_SIZE*h; const vx=(camera.x - (main.width/2)/camera.zoom)/WORLD_SIZE*w; const vy=(camera.y - (main.height/2)/camera.zoom)/WORLD_SIZE*h; miniCtx.strokeStyle='rgba(255,255,255,0.8)'; miniCtx.lineWidth=1; miniCtx.strokeRect(vx,vy,vw,vh);
}

// ====== Simulation loop ======
let lastTime=performance.now(); let simTime=0;
function loop(){
  const now=performance.now(); let dt=(now-lastTime)/1000; lastTime=now; if(dt>0.1) dt=0.1;
  const speed=+speedSel.value; const dtSim=dt*speed;
  if(!paused){
    let acc=dtSim; const step=0.025;
    while(acc>1e-6){ const d=Math.min(step,acc); updateSim(d); acc-=d; simTime+=d; }
    if(camera.follow==='GREEN' && greens.length){ camera.x=greens[0].pos.x; camera.y=greens[0].pos.y; }
    else if(camera.follow==='ORANGE' && oranges.length){ camera.x=oranges[0].pos.x; camera.y=oranges[0].pos.y; }
    for(let i=goals.length-1;i>=0;i--){ const g=goals[i]; if(g.ttl!=null){ g.ttl-=dtSim; if(g.ttl<=0) goals.splice(i,1);} if(g._reached) goals.splice(i,1); }
    if (simTime - lastGoalSpawn >= goalInterval) { if (goals.length < 1) { spawnRandomGoal(); } lastGoalSpawn = simTime; }
  }
  mainCtx.clearRect(0,0,main.width,main.height);
  drawTiles(mainCtx,camera); drawEntities(mainCtx,camera); drawMinimap();
  const avg=arr=>arr.length? (arr.reduce((a,b)=>a+b.fatigue,0)/arr.length):0;
  const ga=avg(greens), oa=avg(oranges);
  const gPct=Math.min(120, Math.round(ga*100)), oPct=Math.min(120, Math.round(oa*100));
  const aHere=greens.length? greens[0].tileAccess():0;
  const mode=greens.length? greens[0].state:'MOVE';
  statsEl.textContent = `t=${simTime.toFixed(1)}s ¬∑ ${speed}√ó ¬∑ G(avg) ${gPct}% ¬∑ O(avg) ${oPct}% ¬∑ access ${aHere.toFixed(2)} ¬∑ mode ${mode}`;
  requestAnimationFrame(loop);
}
function updateSim(dt){ for(let i=0;i<greens.length;i++){ greens[i]._index=i; greens[i].update(dt); } for(let i=0;i<oranges.length;i++){ oranges[i]._index=i; oranges[i].update(dt); } }
requestAnimationFrame(loop);

// ====== DSL ‚Äî Programs & Commands ======
const behaviorPrograms={ GREEN:{params:{}, rules:[]}, ORANGE:{params:{}, rules:[]}, BOT:{} };
function runDSL(text){
  const lines=text.split(/\n/); let i=0; let ok=0, err=0, msgs=[];
  function execLine(line){ try{ parseLine(line); ok++; }catch(e){ err++; msgs.push(`Error: ${e.message} ‚Üê [${line}]`);} }
  while(i<lines.length){
    let raw=lines[i++]; if(!raw) continue;
    let s=raw.trim(); if(!s || s.startsWith('#')) continue;
    if(/^PROGRAM\s+/i.test(s)){ try{ i = parseProgram(lines,i-1); ok++; }catch(e){ err++; msgs.push(`Error: ${e.message}`);} continue; }
    execLine(s);
  }
  dslStatus.textContent = `Executed ${ok} statements` + (err ? ', ' + err + ' errors' : '') + (msgs.length ? ' ‚Äî ' + msgs[0] : '') + '.';
}
function parseProgram(lines,i){
  const head=lines[i].trim(); const parts=head.split(/\s+/);
  let scope=parts[1]?.toUpperCase(); let idx=null;
  if(scope==='BOT'){ idx=parseInt(parts[2]); if(isNaN(idx)) throw new Error('PROGRAM BOT <index>'); }
  const prog={params:{}, rules:[]}; i++;
  while(i<lines.length){
    const L=(lines[i]||'').trim();
    if(!L || L.startsWith('#')){ i++; continue; }
    if(/^END\s*$/i.test(L)){ i++; break; }
    if(/^SET\b/i.test(L)){
      const pairs=L.replace(/^SET\s+/i,'').match(/[a-zA-Z]+\s*=\s*[-+]?\d+(\.\d+)?/g)||[];
      for(const kv of pairs){ const m=kv.match(/([a-zA-Z]+)\s*=\s*([-+]?\d+(\.\d+)?)/); if(m) prog.params[m[1]] = +m[2]; }
      i++; continue;
    }
    if(/^RULE\b/i.test(L)){
      const m=L.match(/^RULE\s+IF\s+(ACCESS|FATIGUE|NEARGOAL|EDGE|RANDOM|NEAROBSTACLE|GOAL_COUNT)\s*(<=|>=|==|<|>)\s*([-+]?\d+(\.\d+)?)\s+THEN\s+(.+)$/i);
      if(!m){ i++; continue; }
      const lhs=m[1].toUpperCase(), op=m[2], rhs=+m[3], actionsStr=m[5];
      const actions=[]; const partsA=actionsStr.split(/\s+/);
      for(let pi=0; pi<partsA.length; pi++){
        const token=partsA[pi];
        if(token.toUpperCase()==='SET'){
          const kv=partsA[++pi]; const mm=kv&&kv.match(/^([a-zA-Z]+)=([-+]?\d+(\.\d+)?)$/);
          if(mm) actions.push({kind:'SET', value:[mm[1], +mm[2]]});
          continue;
        }
        const mm=token.match(/^([A-Z_]+)(?:=([-+]?\d+(\.\d+)?))?$/i);
        if(mm) actions.push({kind:mm[1].toUpperCase(), value: mm[2]? +mm[2] : 0});
      }
      prog.rules.push({lhs, op, rhs, actions}); i++; continue;
    }
    i++;
  }
  if(scope==='BOT' && idx!=null) behaviorPrograms.BOT[idx]=prog; else behaviorPrograms[scope]=prog; return i;
}
function parseLine(s){
  const toks=s.replace(/\s+/g,' ').trim().split(' '); const cmd=toks[0].toUpperCase();
  if(cmd==='WORLD'){
    const size=(s.match(/SIZE\s*=\s*(\d+)/i)||[])[1]; const tiles=(s.match(/TILES\s*=\s*(\d+)/i)||[])[1];
    const edge=(s.match(/EDGE\s*=\s*(\d+)/i)||[])[1]; const wrap=(s.match(/WRAP\s*=\s*(ON|OFF)/i)||[])[1];
    const sd=(s.match(/SEED\s*=\s*(\d+)/i)||[])[1];
    if(size){ WORLD_SIZE=+size; } if(tiles){ TILE_N=+tiles; } if(edge){ EDGE_REPEL_DIST=+edge; }
    if(wrap){ WRAP=(wrap.toUpperCase()==='ON'); } if(sd){ seed=+sd; rand=mulberry32(seed); }
    TILE_SIZE=WORLD_SIZE/TILE_N; regenGrid(); regenStipple(); return;
  }
  if(cmd==='CAMERA'){
    const x=(s.match(/X\s*=\s*([\d.]+)/i)||[])[1]; const y=(s.match(/Y\s*=\s*([\d.]+)/i)||[])[1];
    const zoom=(s.match(/ZOOM\s*=\s*([\d.]+)/i)||[])[1]; const follow=(s.match(/FOLLOW\s*=\s*(GREEN|ORANGE|NONE)/i)||[])[1];
    if(x) camera.x=+x; if(y) camera.y=+y; if(zoom) camera.zoom=clamp(+zoom,0.1,1.5); if(follow){ camera.follow=follow.toUpperCase(); followSel.value=camera.follow; } return;
  }
  if(cmd==='BOTS'){
    const type=toks[1].toUpperCase(); const n=parseInt(toks[2]||'1');
    if(type==='GREEN'){ spawnGreens(n); greenCount.value=String(greens.length); if(n>0 && greens[0]){ camera.x=greens[0].pos.x; camera.y=greens[0].pos.y; } }
    else if(type==='ORANGE'){ spawnOranges(n); orangeCount.value=String(oranges.length); }
    else { throw new Error('BOTS GREEN n | BOTS ORANGE n'); }
    return;
  }
  if(cmd==='BOT'){
    const idx=parseInt(toks[1]); if(isNaN(idx)) throw new Error('BOT index ...'); let target=null;
    const mType=(s.match(/TYPE\s*=\s*(GREEN|ORANGE)/i)||[])[1];
    if(mType){
      if(mType.toUpperCase()==='GREEN'){ if(idx>=greens.length) greens.length=idx+1; if(!greens[idx]) { const p=randomPoint(800); greens[idx]=new GreenBot(p.x,p.y);} target=greens[idx]; }
      else { if(idx>=oranges.length) oranges.length=idx+1; if(!oranges[idx]) { const p=randomPoint(800); oranges[idx]=new OrangeBot(p.x,p.y);} target=oranges[idx]; }
    }
    if(!target){ target=greens[idx]||oranges[idx]; if(!target) throw new Error('No bot at index; set TYPE= to create'); }
    const kvs=s.replace(/BOT\s+\d+\s+/i,'').split(/\s+/);
    for(const kv of kvs){
      const m=kv.match(/([a-zA-Z]+)\s*=\s*([-+]?\d+(?:\.\d+)?)/);
      if(!m) continue; const k=m[1].toLowerCase(), v=+m[2];
      if(k==='fatiguerate'){ target._fatigueLocked=true; target.fatigueRate=v; }
      else target[k]=v;
    } return;
  }
  if(cmd==='SET'){
    const which=toks[1]?.toUpperCase();
    if(which==='GREEN'){
      const pairs=s.match(/[a-zA-Z]+\s*=\s*[-+]?\d+(\.\d+)?/g)||[];
      for(const g of greens){
        for(const kv of pairs){
          const m=kv.match(/([a-zA-Z]+)\s*=\s*([-+]?\d+(\.\d+)?)/);
          if(!m) continue; const key=m[1], val=+m[2];
          if(key==='fatigueRate'){ BASE_FATIGUE.GREEN=val; if(!g._fatigueLocked) g.fatigueRate=BASE_FATIGUE.GREEN*FATIGUE_SCALE; }
          else { g[key]=val; }
        }
      }
      avoidSlider.value=greens[0]?.avoid??avoidSlider.value; avoidVal.textContent=(greens[0]?.avoid??+avoidSlider.value).toFixed(2);
      return;
    }
    if(which==='ORANGE'){
      const pairs=s.match(/[a-zA-Z]+\s*=\s*[-+]?\d+(\.\d+)?/g)||[];
      for(const o of oranges){
        for(const kv of pairs){
          const m=kv.match(/([a-zA-Z]+)\s*=\s*([-+]?\d+(\.\d+)?)/);
          if(!m) continue; const key=m[1], val=+m[2];
          if(key==='fatigueRate'){ BASE_FATIGUE.ORANGE=val; if(!o._fatigueLocked) o.fatigueRate=BASE_FATIGUE.ORANGE*FATIGUE_SCALE; }
          else { o[key]=val; }
        }
      }
      return;
    }
    throw new Error('SET GREEN ... | SET ORANGE ...');
  }
  if(cmd==='BENCH'){
    if(toks[1].toUpperCase()==='RANDOM'){
      const n=parseInt(toks[2]||'1'); for(let i=0;i<n;i++){ const p=randomPoint(300); benches.push({x:p.x,y:p.y}); }
    } else {
      const x=parseFloat(toks[1]), y=parseFloat(toks[2]); if(isNaN(x)||isNaN(y)) throw new Error('BENCH x y'); benches.push({x:x,y:y});
    }
    return;
  }
  if(cmd==='CLEAR'){
    const what=toks[1]?.toUpperCase();
    if(what==='BENCHES'){ benches.length=0; return; }
    if(what==='GOALS'){ goals.length=0; return; }
    if(what==='OBSTACLES'){ obstacles.length=0; return; }
    if(what==='TRAILS'){ for(const g of greens) g.trail=[{x:g.pos.x,y:g.pos.y}]; for(const o of oranges) o.trail=[{x:o.pos.x,y:o.pos.y}]; return; }
    if(what==='PROGRAMS'){ behaviorPrograms.GREEN={params:{},rules:[]}; behaviorPrograms.ORANGE={params:{},rules:[]}; behaviorPrograms.BOT={}; return; }
    throw new Error('CLEAR BENCHES|GOALS|OBSTACLES|TRAILS|PROGRAMS');
  }
  if(cmd==='GOAL'){
    if(toks[1].toUpperCase()==='RANDOM'){
      const n=parseInt(toks[2]||'1'); const ttlTok=(s.match(/TTL\s*=\s*([\d.]+)/i)||[])[1]; const rTok=(s.match(/R\s*=\s*([\d.]+)/i)||[])[1];
      for(let i=0;i<n;i++){ const p=randomPoint(800); goals.push({x:p.x,y:p.y,r:rTok?+rTok:80, ttl: ttlTok?+ttlTok:null}); }
    } else {
      const x=parseFloat(toks[1]), y=parseFloat(toks[2]); if(isNaN(x)||isNaN(y)) throw new Error('GOAL x y');
      const rTok=(s.match(/R\s*=\s*([\d.]+)/i)||[])[1]; const ttlTok=(s.match(/TTL\s*=\s*([\d.]+)/i)||[])[1];
      goals.push({x:x,y:y,r:rTok?+rTok:80, ttl: ttlTok?+ttlTok:null});
    }
    return;
  }
  if(cmd==='WEIGHT' && toks[1].toUpperCase()==='GOAL'){
    const gg=(s.match(/green\s*=\s*([\d.]+)/i)||[])[1]; const oo=(s.match(/orange\s*=\s*([\d.]+)/i)||[])[1];
    if(gg!=null){ greens.forEach(g=>g.goalWeight=+gg); } if(oo!=null){ oranges.forEach(o=>o.goalWeight=+oo); }
    return;
  }
  if(cmd==='OBSTACLE'){
    const nums=s.replace(/OBSTACLE\s*/i,'').replace(/END/i,'').trim().split(/\s+/).map(Number);
    if(nums.length<6||nums.some(n=>isNaN(n))) throw new Error('OBSTACLE x1 y1 x2 y2 x3 y3 ... END');
    const pts=[]; for(let i=0;i<nums.length;i+=2){ pts.push({x:nums[i], y:nums[i+1]}); }
    obstacles.push({points:pts}); return;
  }
  if(cmd==='TRAILS'){ const v=(toks[1]||'ON').toUpperCase(); showTrails.checked=(v!=='OFF'); return; }
    if(cmd==='TRAILS_CONF'){ const every=(s.match(/EVERY\s*=\s*([\d.]+)/i)||[])[1]; const maxp=(s.match(/MAXP\s*=\s*([\d]+|INF|INFINITY)/i)||[])[1]; if(every){ greens.forEach(b=>b.trailEvery=+every); oranges.forEach(b=>b.trailEvery=+every); } if(maxp){ window.TRAIL_MAXP = (/inf/i.test(maxp)? Number.POSITIVE_INFINITY : (+maxp|0)); } return; }
  if(cmd==='GOALS'){
    const vv=(toks[1]||'').toUpperCase();
    if(vv==='ON' || vv==='OFF'){ showGoals.checked=(vv!=='OFF'); return; }
    const iTok=(s.match(/INTERVAL\s*=\s*([\d.]+)/i)||[])[1];
    const mTok=(s.match(/MAX\s*=\s*(\d+)/i)||[])[1];
    if(iTok) goalInterval = Math.max(1, +iTok);
    if(mTok) goalMax = Math.max(0, +mTok|0);
    return;
  }
  if(cmd==='ACCESS' && toks[1].toUpperCase()==='OVERLAY'){ const v=(toks[2]||'ON').toUpperCase(); showAccess.checked=(v!=='OFF'); return; }
  if(cmd==='SPEED'){ const v=toks[1].toUpperCase(); speedSel.value=(v==='5X')?'5':'1'; return; }
  if(cmd==='FOLLOW'){ const v=(toks[1]||'GREEN').toUpperCase(); camera.follow=v; followSel.value=v; return; }
  if(cmd==='EXPORT'){ const size=(s.match(/SIZE\s*=\s*(\d+)/i)||[])[1]; if(size){ EXPORT_SIZE = Math.max(256, Math.min(20000, +size|0)); } return; }
  if(/^TRAIL_LINEWIDTH\s*=/i.test(s)){ const lw=(s.match(/TRAIL_LINEWIDTH\s*=\s*([\d.]+)/i)||[])[1]; if(lw){ const v=Math.max(0.5, Math.min(100, +lw)); EXPORT_LINEWIDTH = v; RUNTIME_TRAIL_LINEWIDTH = v; if(trailW){ trailW.value=String(v); trailWVal.textContent=String(v);} } return; }
  if(cmd==='SAVE' && toks[1].toUpperCase()==='TRAILS'){
    const sizeTok=(s.match(/SIZE\s*=\s*(\d+)/i)||[])[1];
    const file=(s.match(/NAME\s*=\s*([\w\-.]+)/i)||[])[1];
    const lwTok=(s.match(/LINEWIDTH\s*=\s*([\d.]+)/i)||[])[1];
    const size = sizeTok? +sizeTok : EXPORT_SIZE; const lw = lwTok? +lwTok : RUNTIME_TRAIL_LINEWIDTH;
    saveTrailsPNG(size, file||'dual-bot-trails.png', lw); return;
  }
  if(cmd==='OBSTACLES'){
    const blk=(s.match(/BLOCK\s*=\s*(GREEN|ORANGE|BOTH|NONE)/i)||[])[1];
    if(blk){
      const v=blk.toUpperCase();
      if(v==='GREEN'){ OBST_BLOCK_GREEN=true; OBST_BLOCK_ORANGE=false; }
      else if(v==='ORANGE'){ OBST_BLOCK_GREEN=false; OBST_BLOCK_ORANGE=true; }
      else if(v==='BOTH'){ OBST_BLOCK_GREEN=true; OBST_BLOCK_ORANGE=true; }
      else if(v==='NONE'){ OBST_BLOCK_GREEN=false; OBST_BLOCK_ORANGE=false; }
      return;
    }
    const gTok=(s.match(/GREEN\s*=\s*(BLOCK|PASS)/i)||[])[1];
    const oTok=(s.match(/ORANGE\s*=\s*(BLOCK|PASS)/i)||[])[1];
    if(gTok){ OBST_BLOCK_GREEN = (gTok.toUpperCase()==='BLOCK'); }
    if(oTok){ OBST_BLOCK_ORANGE = (oTok.toUpperCase()==='BLOCK'); }
    return;
  }
  if(cmd==='RESET'){ resetWorld(true); return; }
  throw new Error('Unknown command');


// --- NEW: CLEAR OBSTACLES ---
if (/^CLEAR\s+OBSTACLES\b/i.test(s)) { obstacles.length = 0; return; }

// --- NEW: OBSTACLE CIRCLE x y r ---
// e.g., OBSTACLE CIRCLE 5000 5000 1200
let mCircle = s.match(/^OBSTACLE\s+CIRCLE\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/i);
if (mCircle) {
  const cx = +mCircle[1], cy = +mCircle[2], r = +mCircle[3];
  addCircleObstacle(cx, cy, r);
  return;
}


// --- NEW: PALETTE CBSAFE=ON|OFF (or TRUE|FALSE) ---
let mCBS = s.match(/^PALETTE\s+CBSAFE\s*=\s*(ON|OFF|TRUE|FALSE)\b/i);
if (mCBS){
  const v = mCBS[1].toUpperCase();
  const on = (v==='ON' || v==='TRUE');
  if (typeof setCBPalette === 'function') setCBPalette(on);
  return;
}
// --- NEW: COLORBLIND SAFE ON|OFF ---
let mCBS2 = s.match(/^COLORBLIND\s+SAFE\s+(ON|OFF)\b/i);
if (mCBS2){
  const on = mCBS2[1].toUpperCase()==='ON';
  if (typeof setCBPalette === 'function') setCBPalette(on);
  return;
}

// --- NEW: PALETTE SET GREEN=#xxxxxx ORANGE=#yyyyyy ---
let mSet = s.match(/^PALETTE\s+SET\s+(.*)$/i);
if (mSet){
  const args = mSet[1].trim().split(/\s+/);
  let gHex=null, oHex=null;
  for(let i=0;i<args.length;i++){
    if(/^GREEN=/i.test(args[i])) gHex = args[i].split('=')[1];
    if(/^ORANGE=/i.test(args[i])) oHex = args[i].split('=')[1];
  }
  const root = document.documentElement;
  if(gHex && /^#([0-9A-Fa-f]{6})$/.test(gHex)){
    root.style.setProperty('--green', gHex);
  }
  if(oHex && /^#([0-9A-Fa-f]{6})$/.test(oHex)){
    root.style.setProperty('--orange', oHex);
  }
  if (typeof applyRuntimePalette==='function') applyRuntimePalette();
  return;
}

// --- NEW: PALETTE RESET ---
if (/^PALETTE\s+RESET\b/i.test(s)){
  const root = document.documentElement;
  root.style.setProperty('--green', '#33FF33');
  root.style.setProperty('--orange', '#E65C00');
  if (typeof applyRuntimePalette==='function') applyRuntimePalette();
  return;
}
}

// ====== Start loop ======
requestAnimationFrame(loop);
</script>
</body>
</html>
