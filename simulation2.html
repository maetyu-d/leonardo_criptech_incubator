<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sensing Bots</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121923; --ink:#223141; --text:#cdd6e0; --muted:#8ea0b5;
      --accent:#2fe36e; --accent2:#ff9900; --danger:#e25555; --ok:#2fe36e;
      --shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial}
    header{position:sticky; top:0; z-index:10; background:linear-gradient(180deg,#17202b 0%,#111923 100%); border-bottom:1px solid var(--ink); box-shadow:0 10px 20px rgba(0,0,0,0.25)}
    .row{display:flex; gap:10px; align-items:center; padding:10px; max-width:1400px; margin:0 auto}
    .title{font-weight:700; letter-spacing:.3px; opacity:.95} .spacer{flex:1}
    .btn{background:#16202b; border:1px solid var(--ink); color:var(--text); padding:6px 10px; border-radius:10px; cursor:pointer; box-shadow:inset 0 1px 0 rgba(255,255,255,.03); transition:transform .05s, filter .15s, background .15s}
    .btn:hover{filter:brightness(1.08)} .btn:active{transform:translateY(1px)} .btn.secondary{background:#1a2330} .btn.warn{background:#211818; border-color:#3a1f22; color:#ffb8c0}
    .tag{border:1px solid var(--ink); padding:4px 8px; border-radius:999px; font-size:12px; color:var(--muted); background:#0f151d} .tag.ok{color:var(--ok); border-color:#1e3b2a; background:#0e1912} .tag.stop{color:#ffb5b5; border-color:#3a2020; background:#1a1010}
    .slider{display:flex; align-items:center; gap:8px} .slider input[type=range]{width:180px} .kv{display:flex; gap:8px; align-items:center}
    main{max-width:1400px; margin:12px auto; padding:0 10px;} .grid{display:grid; grid-template-columns:1.2fr 1fr; gap:12px}
    .panel{background:var(--panel); border:1px solid var(--ink); border-radius:14px; padding:10px; box-shadow:var(--shadow); position:relative}
    .panel h3{margin:0 0 10px 0; font-size:13px; font-weight:700; color:#a9b7c6; letter-spacing:.3px} .panel .sub{color:var(--muted); font-size:12px}
    .view{display:flex; flex-direction:column; gap:10px} .canvas-wrap{position:relative; background:#0a0f14; border:1px solid var(--ink); border-radius:12px; overflow:hidden}
    canvas{display:block; width:100%; height:100%} .view .overlay-border{position:absolute; inset:0; pointer-events:none; border:1px solid rgba(255,255,255,.06); border-radius:12px}
    .flex{display:flex; gap:12px} .col{display:flex; flex-direction:column; gap:12px}
    .stats{display:grid; grid-template-columns:auto 1fr; gap:6px 12px; font-size:12px} .stats dt{color:#8aa2b8} .stats dd{margin:0; color:#d6dee7}
    #chart{width:100%; height:160px; display:block; background:#0f151d; border:1px solid var(--ink); border-radius:10px}
    .controls{display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; align-items:end}
    .controls label{display:flex; flex-direction:column; gap:4px; font-size:12px; color:#9bb0c6}
    .controls input[type=number]{background:#0f151d; color:var(--text); border:1px solid var(--ink); padding:6px 8px; border-radius:8px}
    .controls input[type=checkbox]{transform:translateY(1px)} .controls select,.controls input[type=range]{background:#0f151d; border:1px solid var(--ink); border-radius:8px}
    .swatch{width:40px; height:28px; border:1px solid var(--ink); border-radius:6px; background:#000}
    textarea{width:100%; min-height:160px; background:#0c1218; color:#dbe6f3; border:1px solid var(--ink); border-radius:10px; padding:8px; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace}
    .footer-note{font-size:12px; color:#8095aa} .error{color:#ffb5b5}
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="title">Sensing Bots</div>
      <div class="spacer"></div>
      <div class="kv">State: <span id="stateTag" class="tag ok">Running</span></div>
      <div class="kv">Fatigue: <span id="fatigueBar" class="tag" title="Focused bot fatigue">0%</span></div>
      <button id="btnPause" class="btn">Pause</button>
      <button id="btnStep" class="btn secondary" title="Step one tick when paused">Step</button>
      <div class="slider" title="Follow-cam zoom"><span>Zoom</span><input id="zoom" type="range" min="0" max="1" step="0.001" value="0.45" /></div>
      <div class="slider" title="Simulation speed"><span>Speed</span><input id="speed" type="range" min="0.05" max="5" step="0.01" value="1" /><span id="speedTag" class="tag">1.00×</span></div>
      <div class="slider" title="Darkness threshold: tiles below this render black"><span>Black &lt;</span><input id="darkThreshold" type="range" min="0" max="1" step="0.01" value="0.5" /><span id="darkTag" class="tag">0.50</span></div>
      <button id="btnExport" class="btn warn" title="Export 10k×10k trails only (A then B)">Export 10k Trail PNG</button>
    </div>
  </header>
  <main>
    <div class="grid">
      <div class="col">
        <div class="panel view">
          <div class="canvas-wrap" style="height:420px"><canvas id="viewFollow"></canvas><div class="overlay-border"></div></div>
        </div>
        <div class="flex">
          <div class="panel" style="flex:1"><h3>Focused Bot — Stats</h3><dl class="stats" id="statsGrid"></dl></div>
          <div class="panel" style="flex:1"><h3>Sensor Chart (30s / 10 Hz)</h3><canvas id="chart"></canvas></div>
        </div>
      </div>
      <div class="col">
        <div class="panel view">
          <div class="canvas-wrap" style="height:540px"><canvas id="viewMap"></canvas><div class="overlay-border"></div></div>
          <div class="panel" style="margin:0; background:transparent; border:none; box-shadow:none; padding:0">
            <div class="flex" style="align-items:center; gap:10px">
              <button id="btnBrushToggle" class="btn secondary">Brush: Off</button>
              <div class="controls" style="flex:1">
                <label>Size (px)<input id="brushSize" type="number" min="10" max="5000" step="10" value="600" /></label>
                <label>Value (0–1)<input id="brushVal" type="number" min="0" max="1" step="0.01" value="0.85" /></label>
                <label>Soft<input id="brushSoft" type="checkbox" checked /></label>
                <label>Mode
                  <select id="brushMode"><option value="set">Set</option><option value="add">Add</option><option value="sub">Sub</option></select>
                </label>
              </div>
              <div><div class="sub" style="margin-bottom:4px">Preview</div><div id="brushSwatch" class="swatch"></div></div>
            </div>
            <div class="footer-note" style="margin-top:6px">Tip: Right-click on the map to erase to black. Brush paints the <em>brightness grid</em> and re-renders the world background.</div>
          </div>
        </div>
        <div class="panel">
          <h3>World DSL</h3>
          <details id="dslHelp" style="margin:6px 0 10px;">
            <summary style="cursor:pointer">Show DSL paths & ready-made macros</summary>
            <pre style="white-space:pre-wrap; font-size:12px; color:#cfe1f0; background:#0b1219; border:1px solid var(--ink); padding:8px; border-radius:10px;">
# --- Set on focused bot ---
set bot.maxSpeed 200
set bot.kp 6.0
set bot.kd 1.2
set bot.wheelRatio 0.7
set bot.asymBiasConst 1.4
set bot.asymResponse 0.7
set bot.limp.amp 0.5
set bot.limp.freq 0.12
set bot.limp.bias 1.57
set bot.color #33FF33
set bot.trailColor #33FF33
set bot.trailWidth 3
set bot.trailOpacity 0.8
# Sensors
set bot.sensors.d1 260
set bot.sensors.d2 480
set bot.sensors.nearOff 0.35
set bot.sensors.farOff 0.90
# Control
set bot.control.deltaGain 0.28
set bot.control.darkAmplify 1.0
set bot.control.flankNudge 0.10
set bot.control.contrastThreshold 0.07
set bot.control.dimSeekDampWeak 0.30
set bot.control.dimSeekDampStrong 0.80
set bot.control.goalGain 0.60
# Model & speed
set bot.model.turnSlowCap 0.65
set bot.speedMap.darkBase 0.80
set bot.speedMap.brightAdd 0.20
# Social (optional flocking-ish)
set bot.social.cohesionR 600
set bot.social.cohesionGain 0.50
set bot.social.alignR 600
set bot.social.alignGain 0.35
set bot.social.sepR 140
set bot.social.sepGain 0.40
set bot.social.sameTypeOnly true
# Fatigue
set bot.fatigueRateScalar 1.0
set bot.restSeconds 15

# --- Per-type defaults (affect current & future bots) ---
setType A wheelRatio 0.70
setType A sensors.d1 250
setType A control.deltaGain 0.24
setType B speedMap.darkBase 0.55

# --- Ready-made macros (use: call <name>) ---
call sharpASeeker
call limp
call lazyBCruiser
call flockLiteA
call denseFlockB
call mazeRunner
call arenaObstacles
call brightCorridor
call thiccTrails
call resetWorld
            </pre>
          </details>
          <textarea id="dsl" spellcheck="false"># ===============================
# Pass 1 — Obstacles (executed first)
# ===============================
clearObstacles
addObstacle 0/0 1000/0 1000/1000 0/1000

# ===============================
# Macros (ready-made presets)
# Use: call &lt;name&gt;
# ===============================
macro sharpASeeker
  setType A control.deltaGain 0.30
  setType A control.contrastThreshold 0.06
  setType A control.dimSeekDampWeak 0.28
  setType A control.dimSeekDampStrong 0.72
  setType A control.flankNudge 0.10
  setType A sensors.d1 260
  setType A sensors.d2 520
  setType A wheelRatio 0.72
  setType A asymResponse 0.75
  setType A maxSpeed 180
end

macro lazyBCruiser
  setType B control.deltaGain 0.22
  setType B control.darkAmplify 0.8
  setType B control.flankNudge 0.06
  setType B model.turnSlowCap 0.65
  setType B speedMap.darkBase 0.70
  setType B speedMap.brightAdd 0.25
  setType B maxSpeed 140
  setType B speedNoise 0.02
  setType B steerNoise 0.10
end

macro flockLiteA
  setType A social.cohesionR 700
  setType A social.alignR 700
  setType A social.sepR 160
  setType A social.cohesionGain 0.45
  setType A social.alignGain 0.30
  setType A social.sepGain 0.35
  setType A social.sameTypeOnly true
end

macro denseFlockB
  setType B social.cohesionR 600
  setType B social.alignR 600
  setType B social.sepR 120
  setType B social.cohesionGain 0.55
  setType B social.alignGain 0.45
  setType B social.sepGain 0.40
  setType B social.sameTypeOnly true
end

macro flockOff
  setType A social.cohesionGain 0
  setType A social.alignGain 0
  setType A social.sepGain 0
  setType B social.cohesionGain 0
  setType B social.alignGain 0
  setType B social.sepGain 0
end

macro arenaObstacles
  clearObstacles
  addObstacle 1500/1500 3500/1400 3600/3200 1400/3300
  addObstacle 6500/2000 8500/2000 8500/3500 6500/3600
  addObstacle 4000/6500 6000/6400 6100/8000 3900/8100
end

macro brightCorridor
  paintRect 0 4800 10000 400 0.85
  paintRect 2000 0 400 10000 0.85
end

macro thiccTrails
  setType A trailWidth 4
  setType B trailWidth 4
  setType A trailOpacity 0.95
  setType B trailOpacity 0.95
end

macro limp
  setType A wheelRatio 0.55
  setType A asymBiasConst 1.6
  setType A asymResponse 0.9
  setType A limp.amp 0.70
  setType A limp.freq 0.07

  setType A control.deltaGain 0.18
  setType A control.contrastThreshold 0.12
  setType A control.dimSeekDampWeak 0.22
  setType A control.dimSeekDampStrong 0.60

  setType A sensors.d1 180
  setType A sensors.d2 320
  setType A steerNoise 0.30

  setType A model.turnSlowCap 0.90
  setType A speedMap.darkBase 0.45
  setType A speedMap.brightAdd 0.15
  setType A maxSpeed 110

  setType A fatigueRateScalar 2.5
  setType A restSeconds 25
end

macro mazeRunner
  clearObstacles
  addObstacle 1200/1200 8800/1200 8800/1400 1200/1400
  addObstacle 1200/8600 8800/8600 8800/8800 1200/8800
  addObstacle 1200/1400 1400/1400 1400/8600 1200/8600
  addObstacle 8600/1400 8800/1400 8800/8600 8600/8600
  addObstacle 1600/2200 8400/2200 8400/2400 1600/2400
  addObstacle 1600/3200 8400/3200 8400/3400 1600/3400
  addObstacle 1600/4200 8400/4200 8400/4400 1600/4400
  addObstacle 1600/5200 8400/5200 8400/5400 1600/5400
  addObstacle 1600/6200 8400/6200 8400/6400 1600/6400
  addObstacle 1600/7200 8400/7200 8400/7400 1600/7400
  addObstacle 3000/1600 3200/1600 3200/8200 3000/8200
  addObstacle 5000/1600 5200/1600 5200/8200 5000/8200
  addObstacle 7000/1600 7200/1600 7200/8200 7000/8200
end

macro resetWorld
  regenLight
  setDarkThreshold 0.5
  clearBots
  spawnA 6
  spawnB 6
  focus 0
end

# ===============================
# Pass 2 — Spawns & Settings
# ===============================
spawnA 6
spawnB 6
focus 0

setType A wheelRatio 0.70
setType A limp.amp 0.45
setType A speedNoise 0.05
setType A fatigueNoise 0.10
setType B trailColor #E65C00
set bot.trailWidth 4

paintRect 2000 2000 1200 800 0.9
paintCircle 6000 6000 900 0.1

setDarkThreshold 0.5

#call sharpASeeker
#call limp
#call lazyBCruiser
#call flockLiteA
#call denseFlockB
#call mazeRunner
#call brightCorridor
#call thiccTrails
#call resetWorld</textarea>
          <div id="dslError" class="error"></div>
        </div>
      </div>
    </div>
  </main>
  <script>
  // Utils
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a=1,b=0)=>Math.random()*(b-a)+a;
  const hexColorSafe=(s,f)=>/^#?[0-9a-fA-F]{6}$/.test(s||'')?(s[0]==='#'?s:'#'+s):f;
  const wrapAngle=a=>{while(a>Math.PI)a-=Math.PI*2;while(a<-Math.PI)a+=Math.PI*2;return a};
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy};

  // World & light
  const WORLD_W=10000,WORLD_H=10000,GRID_N=100,TILE=100;
  const DPR=Math.max(1,Math.min(window.devicePixelRatio||1,2));
  const state={running:true,stepOnce:false,speed:1.0,darkThreshold:0.5,_userDarkOverride:false,showLabels:false,trailEnabled:true,zoomT:0.45};
  const grid=new Float32Array(GRID_N*GRID_N);
  let bgCanvasA=null,trailA=null,trailB=null,trailACtx=null,trailBCtx=null;

  function tryCreateBigCanvas(){const c=document.createElement('canvas'); c.width=WORLD_W; c.height=WORLD_H; return c;}
  function initOffscreens(){
    try{
      bgCanvasA=tryCreateBigCanvas(); trailA=tryCreateBigCanvas(); trailB=tryCreateBigCanvas();
      trailACtx=trailA.getContext('2d',{alpha:true,desynchronized:true});
      trailBCtx=trailB.getContext('2d',{alpha:true,desynchronized:true});
      trailACtx.lineCap='round'; trailACtx.lineJoin='round'; trailBCtx.lineCap='round'; trailBCtx.lineJoin='round';
    }catch(e){ console.error(e); alert('⚠️ Unable to allocate 10k×10k canvases. This device may not have enough memory.'); }
  }

  function regenLight(seed=Math.random()*1e9){
    const n=GRID_N;
    const r=(x,y)=>{const s=Math.sin((x*374761393+y*668265263+seed)*0.00003)*43758.5453; return s-Math.floor(s);};
    for(let y=0;y<n;y++)for(let x=0;x<n;x++){const f1=r(x*53,y*47), f2=r(x*9+1000,y*11+2000); grid[y*n+x]=clamp(0.15+0.85*(0.65*f1+0.35*f2),0,1);}
    const tmp=new Float32Array(n*n);
    for(let y=0;y<n;y++)for(let x=0;x<n;x++){let acc=0,cnt=0; for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){const xx=clamp(x+dx,0,n-1),yy=clamp(y+dy,0,n-1); acc+=grid[yy*n+xx]; cnt++;} tmp[y*n+x]=acc/cnt;}
    grid.set(tmp); renderBackgroundBitmap();
    // Default dark threshold = 50% of max brightness (unless user touched slider)
    if(!state._userDarkOverride){ let maxv=0; for(let i=0;i<grid.length;i++) if(grid[i]>maxv) maxv=grid[i]; state.darkThreshold=clamp(0.5*maxv,0,1); const darkSlider=document.getElementById('darkThreshold'); if(darkSlider){ darkSlider.value=state.darkThreshold; document.getElementById('darkTag').textContent=state.darkThreshold.toFixed(2);} }
  }
  function bAt(px,py){const gx=clamp((px|0)/TILE|0,0,GRID_N-1), gy=clamp((py|0)/TILE|0,0,GRID_N-1); return grid[gy*GRID_N+gx];}
  function brightnessToGray(b){ if(b<state.darkThreshold) return 0; const t=(b-state.darkThreshold)/(1-state.darkThreshold+1e-9); return Math.round(lerp(20,235,clamp(t,0,1))); }
  function renderBackgroundBitmap(){
    if(!bgCanvasA) return;
    const ctx=bgCanvasA.getContext('2d',{alpha:false});
    for(let y=0;y<GRID_N;y++){
      for(let x=0;x<GRID_N;x++){
        const g=brightnessToGray(grid[y*GRID_N+x]);
        ctx.fillStyle = g===0 ? '#000' : `rgb(${g},${g},${g})`;
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
      }
    }
  }

  // Obstacles
  const obstacles=[];
  function drawObstacles(ctx,x=0,y=0,scale=1){ctx.save(); ctx.strokeStyle='rgba(150,190,230,0.8)'; ctx.fillStyle='rgba(40,80,120,0.15)'; ctx.lineWidth=2*scale;
    for(const poly of obstacles){ctx.beginPath(); for(let i=0;i<poly.length;i++){const p=poly[i]; const xx=(p[0]-x)*scale,yy=(p[1]-y)*scale; if(i===0)ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);} ctx.closePath(); ctx.fill(); ctx.stroke();}
    ctx.restore();
  }
  function polygonContainsPoint(poly,x,y){let inside=false; const n=poly.length; for(let i=0,j=n-1;i<n;j=i++){const xi=poly[i][0],yi=poly[i][1],xj=poly[j][0],yj=poly[j][1]; const inter=((yi>y)!=(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi+1e-9)+xi); if(inter) inside=!inside;} return inside;}
  function closestPointOnSegment(ax,ay,bx,by,px,py){const abx=bx-ax,aby=by-ay,apx=px-ax,apy=py-ay,ab2=abx*abx+aby*aby; if(!ab2) return [ax,ay]; let t=(apx*abx+apy*aby)/ab2; t=clamp(t,0,1); return [ax+abx*t,ay+aby*t];}
  function escapeVectorFromPolygon(poly,x,y){let minD2=1/0,vx=0,vy=0; for(let i=0;i<poly.length;i++){const a=poly[i],b=poly[(i+1)%poly.length]; const [cx,cy]=closestPointOnSegment(a[0],a[1],b[0],b[1],x,y); const d2=dist2(x,y,cx,cy); if(d2<minD2){minD2=d2; vx=cx-x; vy=cy-y;}} const len=Math.hypot(vx,vy)||1; return [vx/len,vy/len];}

  // Single Goal
  let goal=null; const goalState={on:false,radius:70};
  function spawnSingleGoalRandom(){ goal={x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,r:goalState.radius}; }
  function clearGoal(){ goal=null; }
  function drawGoal(ctx,x=0,y=0,scale=1){ if(!goal) return; ctx.save(); const gx=(goal.x-x)*scale,gy=(goal.y-y)*scale,rr=goal.r*scale; ctx.beginPath(); ctx.arc(gx,gy,rr,0,Math.PI*2); ctx.strokeStyle='rgba(180,255,180,0.9)'; ctx.lineWidth=Math.max(1,2*scale); ctx.stroke(); ctx.globalAlpha=.07; ctx.fillStyle='rgba(120,200,255,1)'; ctx.beginPath(); ctx.arc(gx,gy,rr*.6,0,Math.PI*2); ctx.fill(); ctx.restore(); }

  // Bots
  const TYPE_A='A', TYPE_B='B'; const bots=[]; let focusIndex=0;
  const defaults={
    A:{type:TYPE_A,color:'#33FF33',trailColor:'#33FF33',trailWidth:2,trailOpacity:.9,maxSpeed:150,wheelRatio:.8,asymBiasConst:1.2,asymResponse:.6,
       sensors:{d1:220,d2:420,nearOff:.35,farOff:.90},
       control:{deltaGain:.26,darkAmplify:0,flankNudge:.08,contrastThreshold:.08,dimSeekDampWeak:.35,dimSeekDampStrong:.75,goalGain:.6},
       model:{turnSlowCap:.6}, speedMap:{darkBase:.85,brightAdd:.15},
       social:{cohesionR:600,cohesionGain:0,alignR:600,alignGain:0,sepR:140,sepGain:0,sameTypeOnly:true,maxNeighbors:24},
       limp:{amp:.35,freq:.08,bias:0}, kp:4.0,kd:.9, speedNoise:.05,steerNoise:.2,fatigueNoise:.10, fatigueRateScalar:1.0, restSeconds:15},
    B:{type:TYPE_B,color:'#E65C00',trailColor:'#E65C00',trailWidth:2,trailOpacity:.9,maxSpeed:160,wheelRatio:1.0,asymBiasConst:1.2,asymResponse:.6,
       sensors:{d1:220,d2:420,nearOff:.35,farOff:.90},
       control:{deltaGain:.30,darkAmplify:1.2,flankNudge:.15,contrastThreshold:.08,dimSeekDampWeak:.50,dimSeekDampStrong:.90,goalGain:.6},
       model:{turnSlowCap:.8}, speedMap:{darkBase:.60,brightAdd:.40},
       social:{cohesionR:600,cohesionGain:0,alignR:600,alignGain:0,sepR:140,sepGain:0,sameTypeOnly:true,maxNeighbors:24},
       limp:{amp:0,freq:0,bias:0}, kp:4.0,kd:.9, speedNoise:.03,steerNoise:.12,fatigueNoise:.06, fatigueRateScalar:.5, restSeconds:15}
  };
  function makeBot(t){const base=JSON.parse(JSON.stringify(defaults[t])); const b={...base,x:Math.random()*WORLD_W,y:Math.random()*WORLD_H,heading:Math.random()*Math.PI*2-Math.PI,angVel:0,speed:0,fatigue:0,resting:false,restTimer:0,lastX:null,lastY:null,samples:{ahead:0,L1:0,R1:0,L2:0,R2:0,speed:0,angVel:0}}; b.color=hexColorSafe(b.color,t===TYPE_A?'#33FF33':'#E65C00'); b.trailColor=hexColorSafe(b.trailColor,t===TYPE_A?'#33FF33':'#E65C00'); return b;}
  function spawn(t,n){for(let i=0;i<n;i++) bots.push(makeBot(t));}
  function reflectAtBounds(b){let hit=false; if(b.x<0){b.x=-b.x;b.heading=Math.PI-b.heading;hit=true} if(b.x>WORLD_W){b.x=WORLD_W-(b.x-WORLD_W);b.heading=Math.PI-b.heading;hit=true} if(b.y<0){b.y=-b.y;b.heading=-b.heading;hit=true} if(b.y>WORLD_H){b.y=WORLD_H-(b.y-WORLD_H);b.heading=-b.heading;hit=true} if(hit) b.heading=wrapAngle(b.heading);}
  function sampleLightAt(b,ang,dist){const px=b.x+Math.cos(b.heading+ang)*dist, py=b.y+Math.sin(b.heading+ang)*dist; return bAt(px,py);}
  function desiredHeadingDelta(b){const s=b.sensors||defaults[b.type].sensors; const a=sampleLightAt(b,0,s.d1), L1=sampleLightAt(b,+s.nearOff,s.d1), R1=sampleLightAt(b,-s.nearOff,s.d1), L2=sampleLightAt(b,+s.farOff,s.d2), R2=sampleLightAt(b,-s.farOff,s.d2);
    const grad=(.7*(R1-L1)+.3*(R2-L2)); const ctl=b.control||defaults[b.type].control; const gain=(typeof ctl.deltaGain==='number')?ctl.deltaGain:(b.type===TYPE_A?.26:.30);
    let delta=-grad*gain;
    if(a<state.darkThreshold){const darkness=(state.darkThreshold-a)/(state.darkThreshold+1e-9); const flank=(L1>R1?+1:(R1>L1?-1:0));
      if(b.type===TYPE_A){const thr=ctl.contrastThreshold??.08, dw=ctl.dimSeekDampWeak??.35, ds=ctl.dimSeekDampStrong??.75; const damp=(Math.abs(grad)<thr)?dw:ds; delta*=damp; delta+=(ctl.flankNudge??.08)*flank*darkness;}
      else{delta*=1+(ctl.darkAmplify??1.2)*darkness; delta+=(ctl.flankNudge??.15)*flank*darkness;}
    }
    if(b.type===TYPE_A && b.wheelRatio<1){const asym=(1-b.wheelRatio), resp=b.asymResponse??.6; if(delta>0) delta*=(1+resp*asym); else if(delta<0) delta*=(1-resp*asym);}
    if(goalState.on && goal){const gg=(b.control&&typeof b.control.goalGain==='number')?b.control.goalGain:0; if(gg>0){const ang=Math.atan2(goal.y-b.y,goal.x-b.x), err=wrapAngle(ang-b.heading); delta+=gg*err;}} b.samples={ahead:a,L1,R1,L2,R2,speed:b.speed,angVel:b.angVel}; return delta;}
  function socialAdjust(b){const soc=b.social||defaults[b.type].social; const gC=+soc.cohesionGain||0,gA=+soc.alignGain||0,gS=+soc.sepGain||0; if(gC===0&&gA===0&&gS===0)return 0; const rC=+soc.cohesionR||0,rA=+soc.alignR||0,rS=+soc.sepR||0; const maxR=Math.max(rC,rA,rS); if(maxR<=0)return 0; const maxR2=maxR*maxR,rC2=rC*rC,rA2=rA*rA,rS2=rS*rS; const sameOnly=(soc.sameTypeOnly!==false); const cap=Math.max(1,soc.maxNeighbors||24);
    let cntC=0,sumCx=0,sumCy=0,cntA=0,sumCos=0,sumSin=0,repX=0,repY=0,seen=0;
    for(let i=0;i<bots.length;i++){const o=bots[i]; if(o===b)continue; if(sameOnly&&o.type!==b.type)continue; const d2=(o.x-b.x)*(o.x-b.x)+(o.y-b.y)*(o.y-b.y); if(d2>maxR2)continue; seen++; if(seen>cap)break; if(d2<=rC2){cntC++; sumCx+=o.x; sumCy+=o.y;} if(d2<=rA2){cntA++; sumCos+=Math.cos(o.heading); sumSin+=Math.sin(o.heading);} if(d2<=rS2&&d2>1){const inv=1/Math.sqrt(d2); repX+=(b.x-o.x)*inv; repY+=(b.y-o.y)*inv;}} let delta=0; if(gC!==0&&cntC>0){const cx=sumCx/cntC,cy=sumCy/cntC; delta+=gC*wrapAngle(Math.atan2(cy-b.y,cx-b.x)-b.heading);} if(gA!==0&&cntA>0){delta+=gA*wrapAngle(Math.atan2(sumSin,sumCos)-b.heading);} if(gS!==0&&(repX!==0||repY!==0)){delta+=gS*wrapAngle(Math.atan2(repY,repX)-b.heading);} return delta;}
  function updateBot(b,dt,t){
    const rate=b.fatigueRateScalar*.01;
    let escaping=false,ex=0,ey=0;
    if(b.type===TYPE_A){for(const poly of obstacles){if(polygonContainsPoint(poly,b.x,b.y)){const v=escapeVectorFromPolygon(poly,b.x,b.y); ex=v[0];ey=v[1]; escaping=true; break;}}}
    if(b.resting){b.restTimer-=dt*rate; if(b.restTimer<=0){b.resting=false; b.fatigue=0;} return;}
    const lightDelta=desiredHeadingDelta(b), sDelta=socialAdjust(b), delta=lightDelta+sDelta, desired=wrapAngle(b.heading+delta), error=wrapAngle(desired-b.heading);
    const du=error-(b.prevError||0); b.prevError=error; let u=b.kp*error + b.kd*(du/dt);
    const limpTerm=(b.limp.amp||0)*Math.sin(2*Math.PI*(b.limp.freq||0)*t + (b.limp.bias||0));
    const steerNoise=rand(-b.steerNoise,b.steerNoise);
    const asymBias=(1-b.wheelRatio)*(typeof b.asymBiasConst==='number'?b.asymBiasConst:1.2);
    let angVel=u+limpTerm+steerNoise+asymBias;
    const cap=(b.model&&typeof b.model.turnSlowCap==='number')?b.model.turnSlowCap:(b.type===TYPE_A?.6:.8);
    const turnSlow=1-clamp(Math.abs(error)/Math.PI,0,cap);
    const here=bAt(b.x,b.y), sm=b.speedMap||defaults[b.type].speedMap;
    const darkSlow=sm.darkBase+sm.brightAdd*here, baseSpeed=b.maxSpeed*turnSlow*darkSlow, speedNoise=1+rand(-b.speedNoise,b.speedNoise);
    let speed=baseSpeed*speedNoise;
    if(escaping){const escapeSpeed=.10*b.maxSpeed; b.x+=ex*escapeSpeed*dt; b.y+=ey*escapeSpeed*dt; reflectAtBounds(b); b.speed=escapeSpeed; b.angVel=0;}
    else{b.heading=wrapAngle(b.heading+angVel*dt); b.x+=Math.cos(b.heading)*speed*dt; b.y+=Math.sin(b.heading)*speed*dt; reflectAtBounds(b); b.speed=speed; b.angVel=angVel;}
    if(goalState.on && goal){const dx=goal.x-b.x, dy=goal.y-b.y; if(dx*dx+dy*dy<=goal.r*goal.r){ spawnSingleGoalRandom(); }}
    const speedNorm=b.maxSpeed>0?(b.speed/b.maxSpeed):0, effort=Math.min(1,Math.abs(angVel)/10)*.6 + (1-turnSlow)*.4, noise=1+rand(-b.fatigueNoise,b.fatigueNoise);
    b.fatigue=clamp(b.fatigue + (effort*rate*(.5+.5*speedNorm)*dt*noise),0,1);
    if(b.fatigue>=1){b.resting=true; b.restTimer=b.restSeconds*rate;}
    if(state.trailEnabled && !b.resting && trailACtx && trailBCtx){const ctx=b.type===TYPE_A?trailACtx:trailBCtx; ctx.save(); ctx.globalAlpha=clamp(b.trailOpacity,0,1); ctx.strokeStyle=b.trailColor; ctx.lineWidth=b.trailWidth; ctx.beginPath(); const lx=b.lastX??b.x,ly=b.lastY??b.y; ctx.moveTo(lx,ly); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.restore(); }
    b.lastX=b.x; b.lastY=b.y;
  }

  // Rendering
  const viewFollow=document.getElementById('viewFollow'), viewMap=document.getElementById('viewMap');
  const ctxFollow=viewFollow.getContext('2d'), ctxMap=viewMap.getContext('2d');
  const chartCanvas=document.getElementById('chart'); const cctx=chartCanvas.getContext('2d');

  function resizeCanvas(c){const r=c.getBoundingClientRect(); c.width=Math.max(2,Math.floor(r.width*DPR)); c.height=Math.max(2,Math.floor(r.height*DPR));}
  function resizeAll(){resizeCanvas(viewFollow); resizeCanvas(viewMap); resizeCanvas(chartCanvas); drawBrushSwatch();}
  window.addEventListener('resize',resizeAll);

  function drawFollow(){
    if(!bgCanvasA) return; const cw=viewFollow.width,ch=viewFollow.height;
    const camW=lerp(300,12000,clamp(state.zoomT,0,1)), camH=camW/(cw/ch);
    const fb=bots[focusIndex]; const cx=clamp((fb?.x)||WORLD_W/2,camW/2,WORLD_W-camW/2), cy=clamp((fb?.y)||WORLD_H/2,camH/2,WORLD_H-camH/2);
    const sx=cx-camW/2, sy=cy-camH/2;
    ctxFollow.save(); ctxFollow.clearRect(0,0,cw,ch);
    ctxFollow.drawImage(bgCanvasA,sx,sy,camW,camH,0,0,cw,ch);
    if(trailA) ctxFollow.drawImage(trailA,sx,sy,camW,camH,0,0,cw,ch);
    if(trailB) ctxFollow.drawImage(trailB,sx,sy,camW,camH,0,0,cw,ch);
    {const sc=cw/camW; drawObstacles(ctxFollow,sx,sy,sc); drawGoal(ctxFollow,sx,sy,sc); }
    if(bots.length){const sX=cw/camW, sY=ch/camH; for(let i=0;i<bots.length;i++) drawBotIcon(ctxFollow,bots[i],sx,sy,sX,sY,i===focusIndex);}
    ctxFollow.restore();
  }
  function drawMap(){
    if(!bgCanvasA) return; const cw=viewMap.width,ch=viewMap.height; ctxMap.save(); ctxMap.clearRect(0,0,cw,ch);
    const scale=Math.min(cw/WORLD_W, ch/WORLD_H), vw=WORLD_W*scale, vh=WORLD_H*scale, ox=(cw-vw)/2, oy=(ch-vh)/2;
    ctxMap.drawImage(bgCanvasA,0,0,WORLD_W,WORLD_H,ox,oy,vw,vh);
    if(trailA) ctxMap.drawImage(trailA,0,0,WORLD_W,WORLD_H,ox,oy,vw,vh);
    if(trailB) ctxMap.drawImage(trailB,0,0,WORLD_W,WORLD_H,ox,oy,vw,vh);
    ctxMap.save(); ctxMap.strokeStyle='rgba(255,255,255,.35)'; ctxMap.lineWidth=2; ctxMap.strokeRect(ox,oy,vw,vh); ctxMap.restore();
    ctxMap.save(); ctxMap.translate(ox,oy); ctxMap.scale(scale,scale); drawObstacles(ctxMap,0,0,1); drawGoal(ctxMap,0,0,1); ctxMap.restore();
    for(let i=0;i<bots.length;i++){const b=bots[i], bx=ox+b.x*scale, by=oy+b.y*scale; drawBotIconAbs(ctxMap,bx,by,b.heading,b.color,i===focusIndex,'map');}
    drawBrushOverlay(ctxMap,ox,oy,scale);
    ctxMap.restore();
  }
  function drawBotIcon(ctx,b,sx,sy,sxScale,syScale,focused){const x=(b.x-sx)*sxScale, y=(b.y-sy)*syScale; drawBotIconAbs(ctx,x,y,b.heading,b.color,focused,'follow');}
  function drawBotIconAbs(ctx,x,y,heading,color,focused,mode){ctx.save(); ctx.translate(x,y); ctx.rotate(heading); ctx.fillStyle=color; ctx.strokeStyle='rgba(0,0,0,.5)'; const s=(mode==='follow'?1.2:0.45)*DPR; ctx.lineWidth=Math.max(1,.8*DPR); ctx.beginPath(); ctx.moveTo(12*s,0); ctx.lineTo(-10*s,7*s); ctx.lineTo(-6*s,0); ctx.lineTo(-10*s,-7*s); ctx.closePath(); ctx.fill(); ctx.stroke(); if(focused){ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=Math.max(1,1.2*DPR); ctx.stroke();} ctx.restore();}

  // Loop + chart
  let lastTime=performance.now(), simTime=0, acc=0; const DT=1/60, MAX_SUBSTEPS=32;
  function tick(now){const elapsed=Math.min(.25,(now-lastTime)/1000); lastTime=now; if(state.running||state.stepOnce){acc+=elapsed*state.speed; let n=0; while(acc>=DT && n<MAX_SUBSTEPS){step(DT); acc-=DT; simTime+=DT; n++;} state.stepOnce=false;} render(); requestAnimationFrame(tick);}
  function step(dt){for(let i=0;i<bots.length;i++) updateBot(bots[i],dt,simTime); sensorSampleAcc+=dt; if(sensorSampleAcc>=.1){sensorSampleAcc-=.1; pushSensorSample();}}
  function render(){drawFollow(); drawMap(); updateStats(); drawChart(); updateHUD();}

  const stateTag=document.getElementById('stateTag'), fatigueBar=document.getElementById('fatigueBar');
  function updateHUD(){stateTag.textContent=state.running?'Running':'Paused'; stateTag.className='tag '+(state.running?'ok':'stop'); const fb=bots[focusIndex]; if(fb){const pct=Math.round(fb.fatigue*100); fatigueBar.textContent=pct+'%'; fatigueBar.style.borderColor=fb.type===TYPE_A?'#215a3c':'#5a3b21'; fatigueBar.style.background=fb.type===TYPE_A?'#0c1a14':'#1a130c'; fatigueBar.style.color='#d7eadd';} else {fatigueBar.textContent='—';}}

  const statsGrid=document.getElementById('statsGrid');
  function updateStats(){const b=bots[focusIndex]; if(!b){statsGrid.innerHTML='<span class="sub">No bots.</span>'; return;} const effRate=(b.fatigueRateScalar*.01).toFixed(4);
    const list=[['Index',focusIndex],['Type',b.type],['Pos',b.x.toFixed(1)+', '+b.y.toFixed(1)],['Heading°',(b.heading*180/Math.PI).toFixed(1)],['Wheel Ratio',b.wheelRatio.toFixed(2)],
      ['Asym Bias Const',(b.asymBiasConst??1.2).toFixed(2)],['Asym Response',(b.asymResponse??.6).toFixed(2)],
      ['Sensors',`d1:${(b.sensors?.d1??defaults[b.type].sensors.d1)|0}, d2:${(b.sensors?.d2??defaults[b.type].sensors.d2)|0}, near:${(b.sensors?.nearOff??defaults[b.type].sensors.nearOff).toFixed(2)}, far:${(b.sensors?.farOff??defaults[b.type].sensors.farOff).toFixed(2)}`],
      ['Control',`gain:${(b.control?.deltaGain??defaults[b.type].control.deltaGain).toFixed(2)}, nudge:${(b.control?.flankNudge??defaults[b.type].control.flankNudge).toFixed(2)}, darkAmp:${(b.control?.darkAmplify??defaults[b.type].control.darkAmplify).toFixed(2)}, goal:${(b.control?.goalGain??0).toFixed(2)}`],
      ['Turn Cap',(b.model?.turnSlowCap??defaults[b.type].model.turnSlowCap).toFixed(2)],
      ['Speed Map',`base:${(b.speedMap?.darkBase??defaults[b.type].speedMap.darkBase).toFixed(2)} + add:${(b.speedMap?.brightAdd??defaults[b.type].speedMap.brightAdd).toFixed(2)}*b`],
      ['Social',`C:${(b.social?.cohesionR??defaults[b.type].social.cohesionR)|0}/${(b.social?.cohesionGain??0).toFixed(2)} A:${(b.social?.alignR??defaults[b.type].social.alignR)|0}/${(b.social?.alignGain??0).toFixed(2)} S:${(b.social?.sepR??defaults[b.type].social.sepR)|0}/${(b.social?.sepGain??0).toFixed(2)}`],
      ['Limp Amp',(b.limp.amp||0).toFixed(2)],['Fatigue %',Math.round(b.fatigue*100)+'%'],['Eff Fatigue Rate',effRate+' /s'],['Rest Remaining',b.resting?(b.restTimer*(b.fatigueRateScalar*.01)).toFixed(2)+' s':'—'],['PD (kp,kd)',`${b.kp.toFixed(2)}, ${b.kd.toFixed(2)}`],['Max Speed',b.maxSpeed.toFixed(1)],['Trail',`${b.trailWidth}px @ ${(b.trailOpacity*100|0)}%`],['Colors',`${b.color} / ${b.trailColor}`]];
    statsGrid.innerHTML=list.map(([k,v])=>`<dt>${k}</dt><dd>${v}</dd>`).join('');
  }

  // Chart
  let sensorSamples=[], sensorSampleAcc=0;
  function pushSensorSample(){const b=bots[focusIndex]; if(!b) return; sensorSamples.push({...b.samples}); if(sensorSamples.length>300) sensorSamples.shift();}
  function drawChart(){const cw=chartCanvas.width,ch=chartCanvas.height; const ctx=cctx; ctx.save(); ctx.clearRect(0,0,cw,ch); ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(30,5); ctx.lineTo(30,ch-18); ctx.lineTo(cw-5,ch-18); ctx.stroke();
    const leftX=30, top=8, right=cw-8, bottom=ch-20, w=right-leftX, h=bottom-top, N=sensorSamples.length; if(N<2){ctx.restore(); return;}
    let maxR=1; for(const s of sensorSamples){maxR=Math.max(maxR,s.speed||0,Math.abs(s.angVel)||0);}
    function plot(getY,dashed=false){ctx.beginPath(); if(dashed)ctx.setLineDash([6,4]); else ctx.setLineDash([]); for(let i=0;i<N;i++){const x=leftX+(i/(N-1))*w, y=top+(1-getY(sensorSamples[i]))*h; if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();}
    ctx.lineWidth=1; ctx.strokeStyle='rgba(200,220,255,.35)'; plot(s=>s.ahead??0); ctx.strokeStyle='rgba(100,220,180,.6)'; plot(s=>s.L1??0); ctx.strokeStyle='rgba(220,180,100,.6)'; plot(s=>s.R1??0); ctx.strokeStyle='rgba(120,170,220,.6)'; plot(s=>s.L2??0); ctx.strokeStyle='rgba(220,120,170,.6)'; plot(s=>s.R2??0);
    ctx.lineWidth=1.5; ctx.strokeStyle='rgba(200,255,200,.9)'; plot(s=>clamp((s.speed||0)/maxR,0,1)); ctx.strokeStyle='rgba(255,220,220,.9)'; plot(s=>clamp((Math.abs(s.angVel)||0)/maxR,0,1),true);
    ctx.restore();
  }

  // Brushes & map painting
  const brush={on:false,size:600,val:.85,soft:true,mode:'set'};
  const mapCanvas=document.getElementById('viewMap');
  function worldFromMap(ev){const rect=mapCanvas.getBoundingClientRect(); const x=(ev.clientX-rect.left)*DPR, y=(ev.clientY-rect.top)*DPR; const cw=mapCanvas.width,ch=mapCanvas.height; const scale=Math.min(cw/WORLD_W,ch/WORLD_H), vw=WORLD_W*scale,vh=WORLD_H*scale, ox=(cw-vw)/2,oy=(ch-vh)/2; const wx=clamp((x-ox)/scale,0,WORLD_W), wy=clamp((y-oy)/scale,0,WORLD_H); return [wx,wy];}
  function drawBrushOverlay(ctx,ox,oy,scale){ if(!brush.on) return; const r=brush.size*scale/2; ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.lineWidth=2; const mx=lastMouseX,my=lastMouseY; if(mx!=null){ctx.beginPath(); ctx.arc(mx,my,r,0,Math.PI*2); ctx.stroke();} ctx.restore(); }
  const brushSwatch=document.getElementById('brushSwatch');
  function drawBrushSwatch(){const v=clamp((brush.val-state.darkThreshold)/(1-state.darkThreshold+1e-9),0,1); const g=brush.val<state.darkThreshold?0:Math.round(lerp(20,235,v)); brushSwatch.style.background = brush.val<state.darkThreshold ? '#000' : `rgb(${g},${g},${g})`;}
  let lastMouseX=null,lastMouseY=null;
  mapCanvas.addEventListener('mousemove',ev=>{const rect=mapCanvas.getBoundingClientRect(); lastMouseX=(ev.clientX-rect.left)*DPR; lastMouseY=(ev.clientY-rect.top)*DPR;});
  mapCanvas.addEventListener('mouseleave',()=>{lastMouseX=null; lastMouseY=null;});
  function paintCircle(cx,cy,r,val){const gx0=Math.max(0,Math.floor((cx-r)/TILE)), gy0=Math.max(0,Math.floor((cy-r)/TILE)), gx1=Math.min(GRID_N-1,Math.ceil((cx+r)/TILE)), gy1=Math.min(GRID_N-1,Math.ceil((cy+r)/TILE)); for(let gy=gy0;gy<=gy1;gy++){for(let gx=gx0;gx<=gx1;gx++){const x=gx*TILE+TILE/2,y=gy*TILE+TILE/2,d=Math.hypot(x-cx,y-cy); if(d<=r){const idx=gy*GRID_N+gx; if(brush.mode==='set') grid[idx]=clamp(val,0,1); else if(brush.mode==='add') grid[idx]=clamp(grid[idx]+val,0,1); else if(brush.mode==='sub') grid[idx]=clamp(grid[idx]-val,0,1);}}} renderBackgroundBitmap();}

  // DSL runner (two-pass)
  function runDSL(src){
    const lines=src.split(/\r?\n/);
    const blocks={}; const out=[];
    let i=0; while(i<lines.length){let line=lines[i].trim(); i++; if(!line||line.startsWith('#')) continue; if(line.startsWith('macro ')){const name=line.slice(6).trim(); const body=[]; while(i<lines.length && !/^\s*end\s*$/.test(lines[i])){body.push(lines[i]); i++;} i++; blocks[name]=body.join('\n'); continue;} if(line.startsWith('repeat ')){const n=parseInt(line.split(/\s+/)[1]||'1'); const body=[]; while(i<lines.length && !/^\s*end\s*$/.test(lines[i])){body.push(lines[i]); i++;} i++; for(let k=0;k<n;k++) out.push(...body); continue;} if(line.startsWith('call ')){const name=line.slice(5).trim(); if(blocks[name]) out.push(...blocks[name].split(/\n/)); continue;} out.push(line); }
    const pass1=[], pass2=[];
    for(const l of out){const t=l.trim(); if(!t||t.startsWith('#')) continue; const cmd=t.split(/\s+/)[0]; if(cmd==='addObstacle'||cmd==='clearObstacles') pass1.push(t); else pass2.push(t);}
    execLines(pass1); execLines(pass2);
  }
  function parsePair(s){const [x,y]=s.split('/').map(parseFloat); return [x,y];}
  function setPath(obj,pathStr,val){const parts=pathStr.split('.'); let o=obj; for(let i=0;i<parts.length-1;i++){const k=parts[i]; if(!(k in o)) o[k]={}; o=o[k]; } const leaf=parts[parts.length-1]; if(val==='true'||val==='false') o[leaf]=(val==='true'); else if(!isNaN(parseFloat(val))) o[leaf]=parseFloat(val); else o[leaf]=val;}
  function execLines(lines){
    for(const raw of lines){
      const t=raw.trim(); if(!t||t.startsWith('#')) continue;
      const [cmd, ...rest]=t.split(/\s+/); const args=rest;
      switch(cmd){
        case 'spawnA': spawn(TYPE_A, parseInt(args[0]||'1')); break;
        case 'spawnB': spawn(TYPE_B, parseInt(args[0]||'1')); break;
        case 'clearBots': bots.length=0; break;
        case 'focus': focusIndex=clamp(parseInt(args[0]||'0')|0,0,Math.max(0,bots.length-1)); break;
        case 'addObstacle': { const pts=args.map(parsePair).filter(p=>p.length===2); if(pts.length>=3) obstacles.push(pts); } break;
        case 'clearObstacles': obstacles.length=0; break;
        case 'paintRect': { const [x,y,w,h,v]=args.map(parseFloat); for(let gy=Math.floor(y/TILE); gy<Math.ceil((y+h)/TILE); gy++){ if(gy<0||gy>=GRID_N) continue; for(let gx=Math.floor(x/TILE); gx<Math.ceil((x+w)/TILE); gx++){ if(gx<0||gx>=GRID_N) continue; grid[gy*GRID_N+gx]=clamp(v,0,1);}} renderBackgroundBitmap(); } break;
        case 'paintCircle': { const [x,y,r,v]=args.map(parseFloat); const gx0=Math.max(0,Math.floor((x-r)/TILE)), gy0=Math.max(0,Math.floor((y-r)/TILE)), gx1=Math.min(GRID_N-1,Math.ceil((x+r)/TILE)), gy1=Math.min(GRID_N-1,Math.ceil((y+r)/TILE)); for(let gy=gy0;gy<=gy1;gy++){ for(let gx=gx0;gx<=gx1;gx++){ const cx=gx*TILE+TILE/2, cy=gy*TILE+TILE/2; if(Math.hypot(cx-x,cy-y)<=r) grid[gy*GRID_N+gx]=clamp(v,0,1); }} renderBackgroundBitmap(); } break;
        case 'setDarkThreshold': { state.darkThreshold=clamp(parseFloat(args[0]||'0.5'),0,1); document.getElementById('darkThreshold').value=state.darkThreshold; document.getElementById('darkTag').textContent=state.darkThreshold.toFixed(2); renderBackgroundBitmap(); drawBrushSwatch(); } break;
        case 'regenLight': regenLight(); break;
        case 'pause': state.running=(parseInt(args[0]||'1')===0); break;
        case 'trail': state.trailEnabled=(parseInt(args[0]||'1')===1); break;
        case 'export': exportPNG(); break;
        case 'teleport': { const [x,y]=args.map(parseFloat); const b=bots[focusIndex]; if(b){b.x=clamp(x,0,WORLD_W); b.y=clamp(y,0,WORLD_H);} } break;
        case 'nudge': { const [dx,dy]=args.map(parseFloat); const b=bots[focusIndex]; if(b){b.x=clamp(b.x+dx,0,WORLD_W); b.y=clamp(b.y+dy,0,WORLD_H);} } break;
        case 'setType': {
          const type=args[0];
          const path=args[1];
          const value=args.slice(2).join(' ');
          if(defaults[type]){
            setPath(defaults[type], path, value);
            for(const b of bots){ if(b.type===type) setPath(b, path, value); }
          }
          } break;
        case 'set': { const path=args[0]; const value=args.slice(1).join(' '); const b=bots[focusIndex]; if(b) setPath(b, path.startsWith('bot.')?path.slice(4):path, value); } break;
        case 'goals': { const on=(parseInt(args[0]||'1')===1); goalState.on=on; if(on && !goal) spawnSingleGoalRandom(); if(!on) clearGoal(); } break;
        case 'goalRadius': { goalState.radius=Math.max(1,parseFloat(args[0]||goalState.radius)); if(goal) goal.r=goalState.radius; } break;
        case 'spawnGoal': { spawnSingleGoalRandom(); } break;
        case 'clearGoal': { clearGoal(); } break;
      }
    }
  }

  // UI controls
  const btnPause=document.getElementById('btnPause'), btnStep=document.getElementById('btnStep'), speed=document.getElementById('speed'), speedTag=document.getElementById('speedTag'), zoom=document.getElementById('zoom'), darkSlider=document.getElementById('darkThreshold'), darkTag=document.getElementById('darkTag'); const btnExport=document.getElementById('btnExport');
  function updateDarkTag(){darkTag.textContent=state.darkThreshold.toFixed(2);}
  btnPause.onclick=()=>{state.running=!state.running; btnPause.textContent=state.running?'Pause':'Resume';};
  btnStep.onclick=()=>{if(!state.running){state.stepOnce=true;}};
  speed.oninput=()=>{state.speed=parseFloat(speed.value)||1; speedTag.textContent=(Math.round(state.speed*100)/100).toFixed(2)+'×';};
  zoom.oninput=()=>{state.zoomT=parseFloat(zoom.value)||0;};
  darkSlider.oninput=()=>{state._userDarkOverride=true; state.darkThreshold=parseFloat(darkSlider.value)||0.5; updateDarkTag(); renderBackgroundBitmap(); drawBrushSwatch();};
  btnExport.onclick=exportPNG;
  function exportPNG(){ try{ const c=document.createElement('canvas'); c.width=WORLD_W; c.height=WORLD_H; const ctx=c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,c.width,c.height); if(trailA) ctx.drawImage(trailA,0,0); if(trailB) ctx.drawImage(trailB,0,0); c.toBlob(b=>{const a=document.createElement('a'); a.download='trails_10k.png'; a.href=URL.createObjectURL(b); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000);}); }catch(e){ alert('Export failed: '+e.message);} }

  // Goals UI toggle
  function setupGoalsUI(){ const ref=document.getElementById('btnBrushToggle'); const panel=ref && ref.closest('.panel'); const btn=document.createElement('button'); btn.id='btnGoalsToggle'; btn.className='btn secondary'; function sync(){ btn.textContent='Goals: '+(goalState.on?'On':'Off'); } btn.onclick=()=>{ goalState.on=!goalState.on; if(goalState.on && !goal) spawnSingleGoalRandom(); if(!goalState.on) clearGoal(); sync(); }; sync(); if(panel){ const row=document.createElement('div'); row.className='flex'; row.style.cssText='gap:8px; margin-top:8px; flex-wrap:wrap'; row.append(btn); panel.appendChild(row); }}
  window.addEventListener('load', setupGoalsUI);

  // Brush controls wiring
  const btnBrushToggle=document.getElementById('btnBrushToggle'), brushSize=document.getElementById('brushSize'), brushVal=document.getElementById('brushVal'), brushSoft=document.getElementById('brushSoft'), brushMode=document.getElementById('brushMode');
  btnBrushToggle.onclick=()=>{brush.on=!brush.on; btnBrushToggle.textContent='Brush: '+(brush.on?'On':'Off');};
  brushSize.oninput=()=>{brush.size=Math.max(1,parseFloat(brushSize.value)||600);};
  brushVal.oninput=()=>{brush.val=clamp(parseFloat(brushVal.value)||0.85,0,1); drawBrushSwatch();};
  brushSoft.onchange=()=>{brush.soft=brushSoft.checked;};
  brushMode.onchange=()=>{brush.mode=brushMode.value;};

  let painting=false;
  function applyBrush(ev,isRight){ if(!brush.on) return; const [wx,wy]=worldFromMap(ev); const r=brush.size/2; const v=isRight?0:brush.val; paintCircle(wx,wy,r,v); }
  mapCanvas.addEventListener('pointerdown',ev=>{painting=true; applyBrush(ev, ev.button===2);});
  mapCanvas.addEventListener('pointermove',ev=>{if(painting) applyBrush(ev, ev.buttons===2);});
  mapCanvas.addEventListener('pointerup',()=>{painting=false;});
  mapCanvas.addEventListener('contextmenu',ev=>ev.preventDefault());

  // DSL controls
  const dslTa=document.getElementById('dsl'), dslError=document.getElementById('dslError');
  const btnRun=document.createElement('button'); btnRun.className='btn'; btnRun.textContent='Run DSL';
  const btnStepDSL=document.createElement('button'); btnStepDSL.className='btn secondary'; btnStepDSL.textContent='Step Once';
  const btnClearBots=document.createElement('button'); btnClearBots.className='btn secondary'; btnClearBots.textContent='Clear Bots';
  const btnRegenLight=document.createElement('button'); btnRegenLight.className='btn secondary'; btnRegenLight.textContent='Regen Light';
  const btnSetLabels=document.createElement('button'); btnSetLabels.className='btn secondary'; btnSetLabels.textContent='Toggle Labels';

  (function injectDSLButtons(){ const dslEl=document.getElementById('dsl'); if(!dslEl) return; const parentPanel=dslEl.closest('.panel')||dslEl.parentElement; if(!parentPanel) return; const row=document.createElement('div'); row.className='flex'; row.style.cssText='gap:8px; margin-bottom:8px; flex-wrap:wrap'; row.append(btnRun, btnStepDSL, btnClearBots, btnRegenLight, btnSetLabels); const h3=parentPanel.querySelector('h3'); parentPanel.insertBefore(row,(h3&&h3.nextSibling)?h3.nextSibling:parentPanel.firstChild); })();
  btnRun.onclick=()=>{ try{ dslError.textContent=''; runDSL(dslTa.value); } catch(e){ dslError.textContent='DSL Error: '+e.message; } };
  btnStepDSL.onclick=()=>{ state.running=false; state.stepOnce=true; };
  btnClearBots.onclick=()=>{ bots.length=0; };
  btnRegenLight.onclick=()=>{ regenLight(); };
  btnSetLabels.onclick=()=>{ state.showLabels=!state.showLabels; };

  // Initial boot
  function initialResize(){resizeAll();}
  window.addEventListener('load', initialResize);
  initOffscreens(); regenLight();
  spawn(TYPE_A,6); spawn(TYPE_B,6); focusIndex=0;
  requestAnimationFrame(tick);
  </script>
</body>
</html>
